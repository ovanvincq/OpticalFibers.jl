var documenterSearchIndex = {"docs":
[{"location":"ModeSolvers/#OpticalFibers.ModeSolvers-Modes-and-Fields","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers - Modes and Fields","text":"","category":"section"},{"location":"ModeSolvers/#Electromagnetic-Fields","page":"ModeSolvers-Modes and Fields","title":"Electromagnetic Fields","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"This module defines two types of fields: the scalar field (valid in the case of weakly guiding fibers) and the vector field. If the fiber has a cylindrical symmetry, it is sufficient to describe the variations of a scalar field along a radius (the 2D scalar field can be then obtained by multiplying the 1D field by cos(ell theta) or sin(ell theta) where ell is the azimuthal number).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.FiberEMField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.FiberEMField","text":"abstract type FiberEMField end\n\nDescribed an electromagnetic field in a fiber.\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFiberEMField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFiberEMField","text":"abstract type ScalarFiberEMField <:FiberEMField end\n\nDescribed an electromagnetic field in a fiber in the scalar approximation.\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFiberEMField1D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFiberEMField1D","text":"struct ScalarFiberEMField1D <:ScalarFiberEMField\n\nDescribed an electromagnetic field in a fiber with a cylindrical symmetry in the scalar approximation.\n\nnu :: Int - Azimuthal number\nE :: UnitfulField{1,(),ElectricFieldDim}\n\nThe additional property normE gives the norm of the electric field.\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFiberEMField2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFiberEMField2D","text":"struct ScalarFiberEMField2D <:ScalarFiberEMField\n\nDescribed an electromagnetic field in a fiber with a cylindrical symmetry in the scalar approximation.\n\nE :: UnitfulField{2,(),ElectricFieldDim}\n\nThe additional property normE gives the norm of the electric field.\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.VectorFiberEMField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.VectorFiberEMField","text":"struct VectorFiberEMField <: FiberEMField\n\nDescribed an electromagnetic field in a fiber.\n\nE :: UnitfulField{2,(3,),ElectricFieldDim}\nH :: UnitfulField{2,(3,),ElectricFieldDim}\n\nAdditional properties can be computed:\n\nnormE : Norm of the electric field\nEx, Ey, Ez : Electric field components\nnormH : Norm of the magnetic field\nHx, Hy, Hz : Magnetic field components\nP : Poynting vector\nPx, Py, Pz : Poynting vector components\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The fields can be multiplied by a scalar and conjugated. It is also possible to take the real part or the imaginary part of a field. Two fields of the same type can also be added or subtracted.","category":"page"},{"location":"ModeSolvers/#Modes","page":"ModeSolvers-Modes and Fields","title":"Modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A mode is a structure that contains a name, an effective index, the wavelength and, optionally, an electromagnetic field.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"This package assumes that the field is proportionnal to expleft(ibeta z-omega tright).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.Mode","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.Mode","text":"struct Mode{T<:Union{Field,Nothing}}\n\nName :: String\nneff :: Number\nlambda :: realLength\nfield :: FiberEMField or Nothing\n\nAdditional properties can be computed:\n\nbeta : Propagation constant \nalpha : Attenuation constant\nlosses : Losses in dB/km\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#Modes/Fields-conversion","page":"ModeSolvers-Modes and Fields","title":"Modes/Fields conversion","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"It is possible to convert a scalar 1D mode or field to a scalar 2d one. The argument orientation_angle corresponds to the orientation in degrees (0 correspond to cos(ell theta) and 90 to sin(ell theta)).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.convertTo2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.convertTo2D","text":"convertTo2D(f::Union{ScalarFiberEMField1D,Mode{ScalarFiberEMField1D}},orientation_angle::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A mode that contains a scalar field can be converted to a vector one by using the approximation: veck=beta vece_z and E_z=H_z=0. The argument polarization_angle corresponds to the direction of polarization of the vector mode (0 correspond to x and 90 to y)","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.convertToVector","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.convertToVector","text":"convertToVector(m::Mode{ScalarFiberEMField2D},polarization_angle::Real=0)\n\n\n\n\n\nconvertToVector(m::Mode{ScalarFiberEMField1D},orientation_angle::Real=0,polarization_angle::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Propagation-of-modes","page":"ModeSolvers-Modes and Fields","title":"Propagation of modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The field due to the propagation of a mode after a propagation distance z can be calculated. This function simply returns the EMField multiplied by exp(ibeta z).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.getEMField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.getEMField","text":"getEMField(m::Mode,z::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Mode-normalization","page":"ModeSolvers-Modes and Fields","title":"Mode normalization","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The modes given by the mode solvers of this package are not normalized. You can normalize them by using the function normalize!. The vector modes are normalized so as vert iint frac12left(vecEwedgevecH^*right) dS vert=1 and the scalar mode are normalized like vector modes if the optional parameter unitIntegral is false or so as $ \\iint \\vert E \\vert^2 dS=1 $ if unitIntegral is true.","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.normalize","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.normalize","text":"normalize(m::Mode{ScalarFiberEMField};unitIntegral::Bool=true)\n\n\n\n\n\nnormalize(m::Mode{VectorFiberEMField})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Overlap-integral","page":"ModeSolvers-Modes and Fields","title":"Overlap integral","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The overlap integral between two modes or between an EM field and a mode f_1 and f_2 is langle f_1 vert f_2 rangle = iint E_1 E_2^* dS for scalar fields/modes and langle f_1 vert f_2 rangle = iint frac12left(vecE_1 wedge vecH_2^*right)_z dS for vector fields/modes.  ","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.overlap","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.overlap","text":"overlap(f::ScalarFiberEMField1D,m::Mode{ScalarFiberEMField1D})\n\n\n\n\n\noverlap(m1::Mode{ScalarFiberEMField2D},m2::Mode{ScalarFiberEMField2D})\n\n\n\n\n\noverlap(m::Mode{ScalarFiberEMField1D},f::ScalarFiberEMField1D)\n\n\n\n\n\noverlap(function overlap(m1::Mode{ScalarFiberEMField1D},m2::Mode{ScalarFiberEMField1D})\n\n\n\n\n\noverlap(f::ScalarFiberEMField2D,m::Mode{ScalarFiberEMField2D})\n\n\n\n\n\noverlap(m::Mode{ScalarFiberEMField2D},f::ScalarFiberEMField2D)\n\n\n\n\n\noverlap(m1::Mode{VectorFiberEMField},m2::Mode{VectorFiberEMField})\n\n\n\n\n\noverlap(m::Mode{VectorFiberEMField},f::VectorFiberEMField)\n\n\n\n\n\noverlap(f::VectorFiberEMField,m::Mode{VectorFiberEMField})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Effective-area","page":"ModeSolvers-Modes and Fields","title":"Effective area","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The effective area is defined by:","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"for scalar modes: fracleft( iint vert E vert^2 dS right)^2iint vert E vert^4 dS\nfor vector modes, there are two different values [9] : fracmu_0varepsilon_0fracleft(Releft(iint(vecEwedgevecH^*)_z dSright)right)^2iint n_0^2 vert vecEvecE^* vert^2 dS and fracmu_0varepsilon_0fracleft(Releft(iint(vecEwedgevecH^*)_z dSright)right)^2iint n_0^2 left(vecEvecEright)left(vecE^*vecE^*right) dS where n_0 is the refractive index involved in the relation between the nonlinear index n_2 and the third order susceptibility chi^(3). If n0=0, the function assumes that n0â‰ƒneff (correct for weakly-guiding fibers).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.Aeff","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.Aeff","text":"Aeff(m::Mode)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Non-linear-coefficient","page":"ModeSolvers-Modes and Fields","title":"Non-linear coefficient","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"In this function, n2 is the nonlinear index and n0 is the refractive index involved in the relation between n_2 and the third order susceptibility chi^(3). They must be constants or functions of the tuple (r,) in the 1D case or (x,y) in the 2D case. If n0=0, this function assumes that n0â‰ƒneff (which is correct for weakly-guiding fibers).","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.nonLinearCoefficient","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.nonLinearCoefficient","text":"nonLinearCoefficient(m::Mode{ScalarFiberEMField},n2::Union{Unitful.Quantity{<:Number,Unitful.dimension(u\"m^2/W\")},Function})\n\n\n\n\n\nnonLinearCoefficient(m::Mode{VectorFiberEMField},n2::Union{Unitful.Quantity{<:Number,Unitful.dimension(u\"m^2/W\")},Function},n0::Union{Real,Function}=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Mode-Field-Diameter-(MFD)","page":"ModeSolvers-Modes and Fields","title":"Mode Field Diameter (MFD)","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The computation MFD is only valid for Gaussian-like beam (maximum at the center of the fiber and electric field with a constant sign). The MFD is calculated by finding the positions where vert E vert=fracmaxleft(vert Evert right)exp(1) for scalar modes and P_z=fracmaxleft(P_zright)exp(2) for vector modes. The optional parameters theta is the angle (in degrees) between the direction along which the MFD is computed and the x-axis. If the field is not quasi-Gaussian (in the case of a higher order mode for example), the value given by this function has no physical meaning.","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.MFD","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.MFD","text":"MFD(m::Mode{ScalarFiberEMField1D})\n\n\n\n\n\nMFD(m::Mode{ScalarFiberEMField2D},theta::Real=0)\n\n\n\n\n\nMFD(m::Mode{VectorFiberEMField},theta::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Functions-specific-to-FEM-fields/modes","page":"ModeSolvers-Modes and Fields","title":"Functions specific to FEM fields/modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"If the field or mode is computed with a FEM solver, the function writevtk of the package Gridap is overloaded to save the EM field or the mode to a file that can be opened with ParaView.","category":"page"},{"location":"ModeSolvers/#Gridap.Visualization.writevtk","page":"ModeSolvers-Modes and Fields","title":"Gridap.Visualization.writevtk","text":"Gridap.:writevtk(name::String,f::Union{FiberEMField,Mode))\n\n\n\n\n\n","category":"function"},{"location":"PhysicalData/#OpticalFibers","page":"PhysicalData","title":"OpticalFibers","text":"","category":"section"},{"location":"PhysicalData/#Constants","page":"PhysicalData","title":"Constants","text":"","category":"section"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Z0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Z0","text":"Z0=sqrt(mu0/eps0)\n\nVaccum impedance (in Î©)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Z0_Unitful","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Z0_Unitful","text":"Z0_Unitful=sqrt(mu0_Unitful/eps0_Unitful)\n\nVaccum impedance\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.c","page":"PhysicalData","title":"OpticalFibers.PhysicalData.c","text":"c=299792458.0\n\nVelocity of light in vacuum (in m/s)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.c_Unitful","page":"PhysicalData","title":"OpticalFibers.PhysicalData.c_Unitful","text":"c_Unitful=299792458.0*u\"m/s\"\n\nVelocity of light in vacuum\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.eps0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.eps0","text":"eps0=1/(mu0*c^2)\n\nVacuum permittivity (in F/m)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.eps0_Unitful","page":"PhysicalData","title":"OpticalFibers.PhysicalData.eps0_Unitful","text":"eps0_Unitful=1/(mu0_Unitful*c_Unitful^2)\n\nVacuum permittivity\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.h","page":"PhysicalData","title":"OpticalFibers.PhysicalData.h","text":"h=6.62607015e-34\n\nPlanck constant (in J.s)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.h_Unitful","page":"PhysicalData","title":"OpticalFibers.PhysicalData.h_Unitful","text":"h_Unitful=6.62607015e-34*u\"J*s\"\n\nPlanck constant\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.mu0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.mu0","text":"mu0=1.25663706212e-6\n\nVacuum permeability (in H/m)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.mu0_Unitful","page":"PhysicalData","title":"OpticalFibers.PhysicalData.mu0_Unitful","text":"mu0_Unitful=1.25663706212e-6*u\"H/m\"\n\nVacuum permeability\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#Functions","page":"PhysicalData","title":"Functions","text":"","category":"section"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Sa_Ytterbium-Tuple{Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Sa_Ytterbium","text":"Sa_Ytterbium(lambda::Union{Real,Quantity{<:Real,Unitful.ğ‹}})\n\nReturns the absorption cross section (in mÂ²) of ytterbium at wavelength lambda (in meters if lambda is a Real) [2]  \n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_F_Doped_Silica-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_F_Doped_Silica","text":"n_F_Doped_Silica(lambda::Union{Real,Quantity{<:Real,Unitful.ğ‹}},xF::Real)\n\nReturns the refractive index of fluorine-doped silica with a fluorine fraction xF (0 â‰¤ xGe â‰¤ 1) at the wavelength lambda (in meters if lambda is a Real) [3].\n\nDomain of validity: 600 nm â‰¤lambdaâ‰¤ 1800 nm and xF â‰¤ 0.2\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Ge_Doped_Silica-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Ge_Doped_Silica","text":"n_Ge_Doped_Silica(lambda::Union{Real,Quantity{<:Real,Unitful.ğ‹}},xGe::Real;author::Symbol=:Fleming)\n\nReturns the refractive index of germanium-doped silica with a germanium fraction xGe (0 â‰¤ xGe â‰¤ 1) at the wavelength lambda (in meters if lambda is a Real). Two Sellmeier formulas can be used : author=:Fleming [4] and author=:Sunak [3].\n\nDomain of validity:\n\n360 nm â‰¤lambdaâ‰¤ 4300 nm for Fleming's formula\n600 nm â‰¤lambdaâ‰¤ 1800 nm and xGe â‰¤ 0.2 for Sunak's formula\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Germanium-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Germanium","text":"n_Germanium(lambda::Real,T::Real)\n\nReturns the refractive index of Germanium at wavelength lambda (in meters if lambda is a Real) and at temperature T (in Kelvin if T is a Real) [5]  \n\nDomain of validity: 1900 nm â‰¤ lambda â‰¤ 5500 nm and 20 K â‰¤ T â‰¤ 300 K\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Silicon-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Silicon","text":"n_Silicon(lambda::Union{Real,Quantity{<:Real,Unitful.ğ‹}},T::Union{Real,Quantity{<:Real,Unitful.ğš¯}})\n\nReturns the refractive index of Silicon at wavelength lambda (in meters if lambda is a Real) and at temperature T (in Kelvin if T is a Real) [5]  \n\nDomain of validity: 1100 nm â‰¤ lambda â‰¤ 5600 nm and 20 K â‰¤ T â‰¤ 300 K\n\n\n\n\n\n","category":"method"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers-Solvers","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers - Solvers","text":"","category":"section"},{"location":"ModeSolvers-Solvers/#Quasi-analytical-multi-step-index-fibers-solver","page":"ModeSolvers-Solvers","title":"Quasi-analytical multi-step index fibers solver","text":"","category":"section"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"This solver assumes that the fiber consists of several concentric layers of uniform refractive index. The cladding is assumed to be infinite. In each layer, the analytical solutions are the Bessel functions. The solver uses the interface conditions to predict the effective index and the profile of the modes. This method is described in the book written by J. Bures [10].  ","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"This solver only returns guided modes: the effective index of the mode is real and cannot be lower than the refractive index of the outer cladding. ","category":"page"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.multi_step_fiber_modes","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.multi_step_fiber_modes","text":"multi_step_fiber_modes(lambda::realLength,nu::Integer,radius::Union{Vector{<:realLength},realLength},index::Vector{<:Real};field::Bool=false,precision::Float64=1E-12,type::Symbol=:Scalar,firstDivision::Integer=0)\n\nReturns a vector of Mode{ScalarFieldFunction1D} if type=:Scalar or a vector of Mode{VectorFieldFunction2D} if type=:Vector.\n\nlambda: wavelength\nnu: azimuthal number\nradius: outer radius of each layer (the cladding is inifinite and has no radius)\nindex: refractive index of each layer (the cladding is included so that length(index) must be equal to length(radius)+1)\nfield: boolean that indicates if fields must be saved\nprecision: absolute precision required on the effective index \ntype: must be :Scalar (default) or :Vector\nfirstDivision: in the case of a very multimode fiber, you can increase this number if some modes are missing. If firstDivision=0, the value of firstDivision is approximated by the solver.\n\n\n\n\n\nmulti_step_fiber_modes(lambda::Real,nu::Integer,radius::Union{Vector{<:Real},Real},index::Vector{<:Real};field::Bool=false,precision::Float64=1E-12,type::Symbol=:Scalar,firstDivision::Integer=0)\n\nReturns a vector of Mode{ScalarFieldFunction1D} if type=:Scalar or a vector of Mode{VectorFieldFunction2D} if type=:Vector.\n\nlambda: wavelength (m)\nnu: azimuthal number\nradius: outer radius of each layer (m, the cladding is inifinite and has no radius)\nindex: refractive index of each layer (the cladding is included so that length(index) must be equal to length(radius)+1)\nfield: boolean that indicates if fields must be saved\nprecision: absolute precision required on the effective index \ntype: must be :Scalar (default) or :Vector\nfirstDivision: in the case of a very multimode fiber, you can increase this number if some modes are missing. If firstDivision=0, the value of firstDivision is approximated by the solver.\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#Finite-element-mode-solvers","page":"ModeSolvers-Solvers","title":"Finite element mode solvers","text":"","category":"section"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"The FEM solvers are based on Gridap.jl and can compute modes of isotropic (functions FEM1D and FEM2D) and anisotropic fibers (function FEM2D_anisotropic). If a PML is not used, the functions FEM1D and FEM2D compute guided modes only. To compute the leaky modes, the user must add a PML by setting the value of dPML in these functions.  If the fiber is twisted, the computed modes must be vector modes. The function FEM2D_periodic can compute the modes of periodic fibers (for example photonic crystal fibers) but the mesh must also be periodic.","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"The computation of the effective index amounts to an eigenvalue problem which is solved by using the package ArnoldiMethod.jl combined with a LU decomposition performed with LinearAlgebra.jl or MUMPS.jl. Note that in the case of anisotropic fibers (when using a PML for example), the dimension of the matrix is twice as large as in the case of isotropic fibers and MUMPS.jl is generally faster that LinearAlgebra.jl. On the other hand, this is not possible to use MUMPS.jl with Threads.jl because MUMPS.jl uses its own threads system.","category":"page"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM1D","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM1D","text":"FEM1D(lambda::realLength,nu::Int64,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,dPML::realLength=0u\"m\",alphaPML::Real=10)\n\nReturns a vector of Mode{ScalarFieldFEM1D}.   The fiber is assumed to be isotropic with a cylindrical symmetry and is described with its relative permittivity.\n\nlambda: wavelength\nnu: azimuthal number\nn_fonc: function of r that describes the refractive index profile n(r)\nmodel: DiscreteModel generated with GridapGmsh.jl with a unit\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML\nalphaPML: attenuation coefficient of the PML\n\n\n\n\n\nFEM1D(lambda::Real,nu::Int64,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10)\n\nReturns a vector of Mode{ScalarFieldFEM1D}.   The fiber is assumed to be isotropic with a cylindrical symmetry and is described with its relative permittivity.\n\nlambda: wavelength (m)\nnu: azimuthal number\nn_fonc: function of r that describes the refractive index profile n(r)\nmodel: DiscreteModel generated with GridapGmsh.jl (m)\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML (m)\nalphaPML: attenuation coefficient of the PML\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D","text":"FEM2D(lambda::realLength,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,dPML::realLength=0u\"m\",alphaPML::Real=10,boundary_tag::String=\"\",type::Symbol=:Scalar,twistPitch::realLength=Inf*u\"m\")\n\nReturns a vector of Mode{ScalarFieldFEM2D} if type=:Scalar or a vector of Mode{VectorFieldFEM2D} if type=:Vector.   The fiber is assumed to be isotropic and is described with its relative permittivity.\n\nlambda: wavelength\nn_fonc: function of the tuple (x,y) that describes the refractive index profile n(x)\nmodel: DiscreteModel generated with GridapGmsh.jl with an unit\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML\nalphaPML: attenuation coefficient of the PML\nboundary_tag: tag of the boundary in model. If \"\", then the function automatically detects the boundary.\ntype: :Scalar or :Vector\ntwistPitch: twist pitch of the fiber. If Inf*u\"m\", the fiber is untwisted. Works for vector modes only.\n\n\n\n\n\nFEM2D(lambda::Real,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10,boundary_tag::String=\"\",type::Symbol=:Vector,twistPitch::Real=Inf)\n\nReturns a vector of Mode{ScalarFieldFEM2D} if type=:Scalar or a vector of Mode{VectorFieldFEM2D} if type=:Vector.   The fiber is assumed to be isotropic and is described with its relative permittivity.\n\nlambda: wavelength (m)\nn_fonc: function of the tuple (x,y) that describes the refractive index profile n(x)\nmodel: DiscreteModel generated with GridapGmsh.jl (m)\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML (m)\nalphaPML: attenuation coefficient of the PML\nboundary_tag: tag of the boundary in model. If \"\", then the function automatically detects the boundary.\ntype: :Scalar or :Vector\ntwistPitch: twist pitch of the fiber (m). If Inf*u\"m\", the fiber is untwisted. Works for vector modes only.\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D_anisotropic","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D_anisotropic","text":"FEM2D_anisotropic(lambda::realLength,epsilon_ini::Function,mu_ini::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,boundary_tag::String=\"\")\n\nReturns a vector of Mode{VectorFieldFEM2D}. The fiber is anisotropic and described with its relative permittivity tensor and its relative permeability tensor. The PML is assumed to be already included in the tensors epsilon and mu.\n\nlambda: wavelength\nepsilon: tensor3 with functions of (x,y) that describes the relative permittivity tensor profile\nmu: tensor3 with functions of (x,y) that describes the relative permeability tensor profile\nmodel: DiscreteModel generated with GridapGmsh.jl with a unit\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nboundary_tag: tag of the boundary in model.\n\n\n\n\n\nFEM2D_anisotropic(lambda::Real,epsilon_ini::Function,mu_ini::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=1,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,boundary_tag::String=\"\")\n\nReturns a vector of Mode{VectorFieldFEM2D}. The fiber is anisotropic and described with its relative permittivity tensor and its relative permeability tensor. The PML is assumed to be already included in the tensors epsilon and mu.\n\nlambda: wavelength (m)\nepsilon: tensor3 with functions of (x,y) that describes the relative permittivity tensor profile\nmu: tensor3 with functions of (x,y) that describes the relative permeability tensor profile\nmodel: DiscreteModel generated with GridapGmsh.jl (m)\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nboundary_tag: tag of the boundary in model.\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D_periodic","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D_periodic","text":"FEM2D_periodic(lambda::realLength,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=3,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,kt::AbstractVector{<:inverseRealLength}=[0.0,0.0]u\"m^-1\",type::Symbol=:Scalar)\n\nReturns a vector of Mode. The fiber is isotropic and described with its relative permittivity. The mesh must be periodic.\n\nlambda: wavelength\nn_fonc: function of (x,y) that describes the refractive index profile\nmodel: DiscreteModel generated with GridapGmsh.jl with a unit\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nkt: vector of the 2D Brillouin zone\ntype: :Scalar or :Vector\n\n\n\n\n\nFEM2D_periodic(lambda::Real,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=3,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,kt::AbstractVector{<:Real}=[0.0,0.0],type::Symbol=:Scalar)\n\nReturns a vector of Mode. The fiber is isotropic and described with its relative permittivity. The mesh must be periodic.\n\nlambda: wavelength (m)\nn_fonc: function of (x,y) that describes the relative permittivity profile\nmodel: DiscreteModel generated with GridapGmsh.jl\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU, :MUMPS or :CUDSS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nkt: vector of the 2D Brillouin zone (m^-1)\ntype: :Scalar (default) or :Vector\n\n\n\n\n\n","category":"function"},{"location":"Unitful_Gridap/#OpticalFibers-Using-Unitful-and-Gridap","page":"Unitful and Gridap","title":"OpticalFibers - Using Unitful and Gridap","text":"","category":"section"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"OpticalFibers.jl is based on two main packages:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"Unitful.jl that allows to add a unit to quantities\nGridap.jl which is a finite element library","category":"page"},{"location":"Unitful_Gridap/#Unitful","page":"Unitful and Gridap","title":"Unitful","text":"","category":"section"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"For convenience OpticalFibers.jl exports some functions of Unitful.jl: uconvert, uconvertp, uconvertrp, ustrip, @u_str, unit, Units, NoUnits, dimension.","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"Basically, you can create a quantity with a unit and do conversions:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> using OpticalFibers\njulia> lambda=1.0u\"Âµm\"\n1.0 Î¼m\njulia> lambda^2\n1.0 Î¼m^2\njulia> uconvert(u\"m\",lambda)\n1.0e-6 m\njulia> ustrip(lambda)\n1.0\njulia> unit(lambda)\nÎ¼m\njulia> dimension(lambda)\nğ‹","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"If you want to use others functionnalities, please install and load Unitful.jl.","category":"page"},{"location":"Unitful_Gridap/#Gridap","page":"Unitful and Gridap","title":"Gridap","text":"","category":"section"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"For convenience OpticalFibers.jl exports some functions of Gridap.jl and GridapGmsh.jl: integrate, Point, VectorValue, TensorValue, diagonal_tensor, CartesianDiscreteModel, GmshDiscreteModel, writevtk, CellField,cross, simplexify, Triangulation, Measure.","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"With this package, you can create Point, Vectors, Tensor:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> point2D=Point(1.0,2.0)\nVectorValue{2, Float64}(1.0, 2.0)\njulia> vector=VectorValue(5.0,6.0,7.0)\nVectorValue{3, Float64}(5.0, 6.0, 7.0)\njulia> tensor=TensorValue(1.0,3.0,im,6.0)\nTensorValue{2, 2, ComplexF64, 4}(1.0 + 0.0im, 3.0 + 0.0im, 0.0 + 1.0im, 6.0 + 0.0im)\njulia> tensor2=diagonal_tensor(VectorValue(1.0,2.0,3.0))\nTensorValue{3, 3, Float64, 9}(1.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 3.0)\njulia> tensor2â‹…vector\nVectorValue{3, Float64}(5.0, 12.0, 21.0)\njulia> cross(VectorValue(2.5,2.5,0),vector)\nVectorValue{3, Float64}(17.5, -17.5, 2.5)\njulia> cross(VectorValue(2.5,2.5,0),vector)\nVectorValue{3, Float64}(17.5, -17.5, 2.5)","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"You can also create or load meshes:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> model1D = CartesianDiscreteModel((0,15),1500)\nCartesianDiscreteModel()\njulia> model2D = GmshDiscreteModel(\"./models/example1.msh\")\nInfo    : Reading './models/example1.msh'...\nInfo    : 7 entities\nInfo    : 4733 nodes\nInfo    : 9564 elements\nInfo    : Done reading './models/example1.msh'","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"If you want to use others functionnalities, please install and load Gridap.jl and GridapGmsh.jl.","category":"page"},{"location":"Unitful_Gridap/#UnitfulModel","page":"Unitful and Gridap","title":"UnitfulModel","text":"","category":"section"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"In OpticalFibers.jl, a length unit can be added to a model:","category":"page"},{"location":"Unitful_Gridap/#OpticalFibers.UnitfulModel","page":"Unitful and Gridap","title":"OpticalFibers.UnitfulModel","text":"struct UnitfulModel\n\nmodel :: DiscreteModel\nunit :: Unitful.Units{<:Any,Unitful.dimension(u\"m\")}\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"For example:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> unitful_model1D=UnitfulModel(model1D,u\"Âµm\")\nUnitfulModel(CartesianDiscreteModel(), Î¼m)\njulia> unitful_model2D=model2D*u\"nm\"\nUnitfulModel(UnstructuredDiscreteModel(), nm)","category":"page"},{"location":"Unitful_Gridap/#UnitfulField","page":"Unitful and Gridap","title":"UnitfulField","text":"","category":"section"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"UnitfulField is an abstract structure that describes a constant field that depends on space coordinates.","category":"page"},{"location":"Unitful_Gridap/#OpticalFibers.UnitfulField","page":"Unitful and Gridap","title":"OpticalFibers.UnitfulField","text":"abstract type UnitfulField{Dp,Df,dim} <:Function where dim<:Unitful.Dimensions end\n\nDp: dimension of the space: 1, 2, 3...\nDf: dimension of the field: () for a scalar field, (2,) for 2D vector or (3,3) for a 3x3 tensor\ndim: unit dimension of the field\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/#OpticalFibers.ScalarUnitfulField","page":"Unitful and Gridap","title":"OpticalFibers.ScalarUnitfulField","text":"const ScalarUnitfulField{Dp,dim}=UnitfulField{Dp,(),dim}\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/#OpticalFibers.num_space_dims","page":"Unitful and Gridap","title":"OpticalFibers.num_space_dims","text":"function num_space_dims(::UnitfulField{Dp,Df,dim}) where {Dp,Df,dim}\n\nreturns Dp\n\n\n\n\n\n","category":"function"},{"location":"Unitful_Gridap/#OpticalFibers.num_field_dims","page":"Unitful and Gridap","title":"OpticalFibers.num_field_dims","text":"function num_field_dims(::UnitfulField{Dp,Df,dim}) where {Dp,Df,dim}\n\nreturns Df\n\n\n\n\n\n","category":"function"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"A UnitfulField can be created with a matrix, a function or a Gridap field:","category":"page"},{"location":"Unitful_Gridap/#OpticalFibers.ArrayField","page":"Unitful and Gridap","title":"OpticalFibers.ArrayField","text":"struct ArrayField{Dp,Df,dim} <:UnitfulField{Dp,Df,dim}\n\nField defined by an array on a rectangular grid\n\nposition: AbstractVector{AbstractVector{<:realLength}}\nvalue: AbstractArray{<:Number}\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/#OpticalFibers.FunctionField","page":"Unitful and Gridap","title":"OpticalFibers.FunctionField","text":"struct FunctionField{Dp,Df,dim} <:UnitfulField{Dp,Df,dim}\n\nvalue: Function\n\nThe constructor of a FunctionField requires the value of Dp : FunctionField(Dp::Int,value::Function)\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/#OpticalFibers.FEMField","page":"Unitful and Gridap","title":"OpticalFibers.FEMField","text":"struct FEMField{Dp,Df,dim} <:UnitfulField{Dp,Df,dim}\n\nvalue: CellField\ndÎ©: Gridap.CellData.Measure\nPositionUnit: Unitful.Units{<:Any,Unitful.dimension(u\"m\")}\nFieldUnit: Unitful.Units\n\n\n\n\n\n","category":"type"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"Example of creation of a FunctionField:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia>  f(x) = VectorValue(x[1]^2/1u\"m^2\", x[2]^2/1u\"m^2\")u\"V\"\nf (generic function with 1 method)\njulia> ff = FunctionField(2, f)\n(::FunctionField{2, (2,), ğ‹^2 ğŒ ğˆ^-1 ğ“^-3})     (generic function with 3 methods)\njulia> f2(x) = VectorValue(x[1]/1u\"m\",x[2]/1u\"m\")u\"A\"\nf2 (generic function with 1 method)\njulia> ff2 = FunctionField(2, f2)\n(::FunctionField{2, (2,), ğˆ})  (generic function with 3 methods)","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"UnitfulField is a Function so as the field can be evaluated directly:","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> ff(Point(2.0,3.0)u\"m\")\nVectorValue{2, Unitful.Quantity{Float64, ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, Unitful.FreeUnits{(V,), ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, nothing}}}(4.0 V, 9.0 V)\njulia> ff([Point(2.0,3.0)u\"m\",Point(1.0,1.0)u\"m\"])\n2-element Vector{VectorValue{2, Unitful.Quantity{Float64, ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, Unitful.FreeUnits{(V,), ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, nothing}}}}:\n VectorValue{2, Unitful.Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, Unitful.FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1        ğ“^-3, nothing}}}(4.0 V, 9.0 V)\n VectorValue{2, Unitful.Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, Unitful.FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1        ğ“^-3, nothing}}}(1.0 V, 1.0 V)\njulia> ff([2.0u\"m\",5.0u\"m\"],[3.0u\"m\",4.0u\"m\"])\n2Ã—2 Matrix{VectorValue{2, Unitful.Quantity{Float64, ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, Unitful.FreeUnits{(V,), ğ‹ ^2 ğŒ  ğˆ ^-1 ğ“ ^-3, nothing}}}}:\n  VectorValue{2, Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, nothing}}        }(4.0 V, 9.0 V)   VectorValue{2, Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, nothing}}        }(4.0 V, 16.0 V)\n VectorValue{2, Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, nothing}}        }(25.0 V, 9.0 V)  VectorValue{2, Quantity{Float64, ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, FreeUnits{(V,), ğ‹^2 ğŒ ğˆ^-1 ğ“^-3, nothing}}        }(25.0 V, 16.0 V)","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"A lot of operator can be used with UnitfulField (+, *, cross, norm, real...):","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> ffdiv=ff/2u\"W\"\n(::FunctionField{2, (2,), ğˆ^-1})  (generic function with 3 methods)\njulia> dot_ff = dot(ff, VectorValue(1.0, 1.0)u\"V\")\n(::FunctionField{2, (), ğ‹^4 ğŒ^2 ğˆ^-2 ğ“^-6})     (generic function with 3 methods)\njulia> dot_ff(Point(2.0,3.0)u\"m\")\n13.0 V^2\njulia> product_ff = ffâ‹…ff2\n(::FunctionField{2, (), ğ‹^2 ğŒ ğ“^-3})    (generic function with 3 methods)\njulia> uconvert(u\"W\",product_ff(Point(2.0,3.0)u\"m\"))\n35.0 W","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"Integration is also implemented for UnitfulField","category":"page"},{"location":"Unitful_Gridap/","page":"Unitful and Gridap","title":"Unitful and Gridap","text":"julia> integrate(ff,[-1,1]u\"m\",[-2,2]u\"m\")\nVectorValue{2, Unitful.Quantity{Float64, ğ‹ ^4 ğŒ  ğˆ ^-1 ğ“ ^-3, Unitful.FreeUnits{(m^2, V), ğ‹ ^4 ğŒ  ğˆ ^-1 ğ“ ^-3, nothing}}}(-2.33333333333317 m^2 V, -2.3333333333328277 m^2 V)","category":"page"},{"location":"Bibliography/#References","page":"References","title":"References","text":"","category":"section"},{"location":"Bibliography/","page":"References","title":"References","text":"K.Â Saitoh and M.Â Koshiba. Empirical relations for simple design of photonic crystal fibers. Opt.Â Express 13, 267â€“274 (2005).\n\n\n\nJ.Â R.Â Marciante and J.Â D.Â Zuegel. High-gain, polarization-preserving, Yb-doped fiber amplifier for low-duty-cycle pulse amplification. Appl.Â Opt. 45, 6798â€“6804 (2006).\n\n\n\nH.Â Sunak and S.Â Bastien. Refractive index and material dispersion interpolation of doped silica in the 0.6-1.8 Âµm wavelength region. IEEEÂ PhotonicsÂ TechnologyÂ Letters 1, 142â€“145 (1989).\n\n\n\nJ.Â W.Â Fleming. Dispersion in GeO2â€“SiO2 glasses. Appl.Â Opt. 23, 4486â€“4493 (1984).\n\n\n\nB.Â J.Â Frey, D.Â B.Â Leviton and T.Â J.Â Madison. Temperature-dependent refractive index of silicon and germanium. In: Optomechanical Technologies for Astronomy, Vol.Â 6273, edited by E.Â Atad-Ettedgui, J.Â Antebi and D.Â Lemke (International Society for Optics and Photonics, SPIE, 2006); p.Â 62732J.\n\n\n\nA.Â ..Â Snyder and J.Â Love. Optical Waveguide Theory. 1Â Edition (Springer, 1983).\n\n\n\nA.Â Nicolet, F.Â Zolla, Y.Â O.Â Agha and S.Â Guenneau. Leaky modes in twisted microstructured optical fibers. WavesÂ inÂ RandomÂ andÂ ComplexÂ Media 17, 559â€“570 (2007).\n\n\n\nM.Â Napiorkowski and W.Â Urbanczyk. Rigorous simulations of a helical core fiber by the use of transformation optics formalism. Opt.Â Express 22, 23108â€“23120 (2014).\n\n\n\nJ.Â LÃ¦gsgaard. Modeling of nonlinear propagation in fiber tapers. J.Â Opt.Â Soc.Â Am.Â B 29, 3183â€“3191 (2012).\n\n\n\nJ.Â Bures. Optique guidÃ©e. Fibres optiques et composants passifs tout-fibre (Presses internationales Polytechnique, 2009).\n\n\n\n","category":"page"},{"location":"ModeSolvers-Tutorial/#OpticalFibers.ModeSolvers-Tutorial","page":"ModeSolvers-Tutorial","title":"OpticalFibers.ModeSolvers - Tutorial","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/#Bimodal-Step-index-Fiber","page":"ModeSolvers-Tutorial","title":"Bimodal Step-index Fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"This section explains how to modelize a step-index fiber with a core radius a=2 Âµm. The refractive index of the core is n_textcore=147 and that of the cladding is n_textcladding=145. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"This fiber is bimodal at lambda=1 Âµm since the normalized frequency is V=frac2pi alambdasqrtn_textcore^2-n_textcladding^2=304. ","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-Modes","page":"ModeSolvers-Tutorial","title":"Scalar Modes","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the two scalar modes, we can use the fuction multi_step_fiber_modes that returns a vector of modes. The arguments are the wavelength, the azimuthal number, the radius of the core and a vector describing the refractive index. The optional argument field indicates that we want to return modes that contain a field.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"#using Pkg; nothing # hide\n#Pkg.activate(\"../..\"); nothing # hide\nusing OpticalFibers, OpticalFibers.ModeSolvers\nm0=multi_step_fiber_modes(1u\"Âµm\",0,2u\"Âµm\",[1.47,1.45],field=true);\nm01=m0[1]\nm1=multi_step_fiber_modes(1u\"Âµm\",1,2u\"Âµm\",[1.47,1.45],field=true);\nm11=m1[1]\nnothing; #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Note that you can also use broadcasting to compute all modes with a single command. The function Ref allows to use the same vector of refractive index for all values of the azimuthal number. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m=multi_step_fiber_modes.(1u\"Âµm\",[0,1],2u\"Âµm\",Ref([1.47,1.45]),field=true);\nm01=m[1][1];\nm11=m[2][1];\nnothing; #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The mode profile can be easily plotted:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots\nr=(0:0.01:10)*1u\"Âµm\";\nplot(r,m01.EMField.E(r),label=m01.Name)\nplot!(r,m11.EMField.E(r),label=m11.Name)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to visualize the modes in a 2D plot, we can convert the Mode{ScalarFieldFunction1D} to a Mode{ScalarFieldFunction2D} but we have to indicate the orientation of the mode by using the cos function or the sin function. Then, we normalize the modes and plot one of the two LP_11 modes. Be careful when using Plots.jl: unlike this package, the second index of the matrix corresponds to the x-coordinate (as matlab but the opposite of Makie.jl).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mm01=convertTo2D(m01)\nmm11c=convertTo2D(m11)\nmm11s=convertTo2D(m11,90)\nmm01=normalize(mm01)\nmm11c=normalize(mm11c)\nmm11s=normalize(mm11s)\nx=(-8:0.125:8)*1u\"Âµm\";\ncontourf(x,x,mm11c.EMField.E(x,x)',levels=100,linewidth=0)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The beating between the LP_01 and the LP_11 can be observed by plotting the sum of the fields for different values of the distance z. The beating length is frac2pivert Delta beta vert = fraclambdavert Delta n_eff vertsimeq 107 Âµm","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"L=1u\"Âµm\"/(m01.neff-m11.neff)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can take advantage of the possibility to add fields to create the animation.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"anim=@animate for j=0:107\n    TotalField=getEMField(mm01,j*2u\"Âµm\")+getEMField(mm11c,j*2u\"Âµm\");\n    contourf(x,x,abs2.(TotalField.E(x,x))',levels=100,linewidth=0,title=\"z = $(2*j) Âµm\")\nend;\ngif(anim,\"anim_field.gif\",fps=15)","category":"page"},{"location":"ModeSolvers-Tutorial/#Vector-modes","page":"ModeSolvers-Tutorial","title":"Vector modes","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"It is also possible to compute the vector modes of the fiber: LP_01 mode becomes HE_11 mode and LP_11 mode becomes TE_01, TM_01 and HE_21 modes. To compute these modes, we just have to set the argument type to :Vector (its default value is :Scalar).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv0=multi_step_fiber_modes(1u\"Âµm\",0,2u\"Âµm\",[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv1=multi_step_fiber_modes(1u\"Âµm\",1,2u\"Âµm\",[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv2=multi_step_fiber_modes(1u\"Âµm\",2,2u\"Âµm\",[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then, the Poynting vector of the mode HE_21 can be computed and plotted.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"contourf(x,x,(mv2[1].EMField.Pz(x,x))',linewidth=0,levels=100,xlims=(-4u\"Âµm\",4u\"Âµm\"),ylims=(-4u\"Âµm\",4u\"Âµm\"))\nxc=x[1:4:end];\nX,Y=meshgrid(xc);\nquiver!(X,Y,quiver=(real(mv2[1].EMField.Ex(xc,xc)'/20u\"V/m\"),real(mv2[1].EMField.Ey(xc,xc)'/20u\"V/m\")),color=:cyan,arrow=arrow(:closed))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to check the orthoganality of the modes, we can normalize them and compute the overlap integrals:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv=[mv1;mv0;mv2];\nmv=normalize.(mv);\noverlap.(mv,transpose(mv))","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-modes-with-FEM1D","page":"ModeSolvers-Tutorial","title":"Scalar modes with FEM1D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can find the results above using the FEM method. We will start with the 1D method since the fiber has a cylindrical symmetry. The mesh must begin at r=0 and we have set its end at 15 Âµm. The number of elements is set to 1500. We indicate to the the FEM solver that we want to compute 4 eigenvalues but it returns only one since there is only one mode for ell=0.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model = CartesianDiscreteModel((0,15),1500)\nRIP=x->1.47-0.02*(x[1]>=2u\"Âµm\")\nm0FEM=FEM1D(1u\"Âµm\",0,RIP,model*u\"Âµm\",field=true,neigs=4)\nm0FEM=normalize.(m0FEM)\nm0=normalize.(m0)\nplot(r,m0[1].EMField.E(r),label=\"Step-index solver\")\nplot!(r,-m0FEM[1].EMField.E(r),label=\"FEM1D solver\",line=:dash)","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-modes-with-FEM2D","page":"ModeSolvers-Tutorial","title":"Scalar modes with FEM2D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can also use the FEM2D method. For this, we use a mesh created with GMSH and a function of the tuple (xy) that describes the refractive index profile. We ask the solver to find 4 modes but it returns only 3 because the fiber can only guides the modes LP01, LP11a and LP11b (a and b refer to the orientation of the mode).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model = GmshDiscreteModel(\"../../models/example1.msh\");\nRIP2D=x->1.47-0.02*(hypot(x[1],x[2])>=2u\"Âµm\")\nmFEM2D=FEM2D(1*u\"Âµm\",RIP2D,model*u\"Âµm\",field=true,neigs=4)\nmFEM2D=normalize.(mFEM2D);\np1=contourf(x,x,mFEM2D[1].EMField.E(x,x)',levels=50,linewidth=0,aspect_ratio=:equal);\np2=contourf(x,x,mFEM2D[2].EMField.E(x,x)',levels=50,linewidth=0,aspect_ratio=:equal);\np3=contourf(x,x,mFEM2D[3].EMField.E(x,x)',levels=50,linewidth=0,aspect_ratio=:equal);\nplot(p1, p2, p3, layout=(1,3), legend=false,size=(900,300))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Note that there is no preferential orientation for the LP_11 modes given by the FEM solver. We can check that the modes given by the quasi-analytical solver and the FEM solver are the same by computing the overlap integrals:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"abs2.(overlap.(mFEM2D,[mm01 mm11c mm11s]))","category":"page"},{"location":"ModeSolvers-Tutorial/#Vector-modes-with-FEM2D","page":"ModeSolvers-Tutorial","title":"Vector modes with FEM2D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the vector, we just have to set type to :Vector. We ask the solver to find 8 modes but it returns only 6 because the fiber can only guides 2 modes HE_11, 1 mode becomes TE_01, 1 mode TM_01 and 2 modes HE_21. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mvFEM2D=FEM2D(1*u\"Âµm\",RIP2D,model*u\"Âµm\",field=true,neigs=8,type=:Vector)\nmvFEM2D=normalize.(mvFEM2D)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can verify that the modes given by the quasi-analytical solver and the FEM solver are the same by plotting the fields.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"p1=contourf(x,x,real(mvFEM2D[4].EMField.Ex(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ex\");\np2=contourf(x,x,real(mvFEM2D[4].EMField.Ey(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ey\");\np3=contourf(x,x,imag(mvFEM2D[4].EMField.Ez(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ez\");\np4=contourf(x,x,real(mvFEM2D[4].EMField.Hx(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hx\");\np5=contourf(x,x,real(mvFEM2D[4].EMField.Hy(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hy\");\np6=contourf(x,x,imag(mvFEM2D[4].EMField.Hz(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hz\");\nplot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"p1=contourf(x,x,real(mv[4].EMField.Ex(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ex\");\np2=contourf(x,x,real(mv[4].EMField.Ey(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ey\");\np3=contourf(x,x,imag(mv[4].EMField.Ez(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ez\");\np4=contourf(x,x,real(mv[4].EMField.Hx(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hx\");\np5=contourf(x,x,real(mv[4].EMField.Hy(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hy\");\np6=contourf(x,x,imag(mv[4].EMField.Hz(x,x)'),levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hz\");\nplot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))","category":"page"},{"location":"ModeSolvers-Tutorial/#Gradient-index-fiber-and-dispersion","page":"ModeSolvers-Tutorial","title":"Gradient index fiber and dispersion","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this tutorial, a germanium-doped parabolic gradient index fiber will be studied. The maximum Ge concentration is 20% and the core radius is 3.5 Âµm. The silica dispersion will be taken into account.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, a vector of Function is created to modelized the dispersive refractive index profile between 1 and 1.5 Âµm:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots, OpticalFibers, OpticalFibers.PhysicalData, OpticalFibers.ModeSolvers\nlambda=(1:0.01:1.5)u\"Âµm\";\nRIP=[x->n_Ge_Doped_Silica(l,0)+(n_Ge_Doped_Silica(l,0.2)-n_Ge_Doped_Silica(l,0))*(x[1]<=3.5u\"Âµm\")*(1-x[1]^2/(3.5u\"Âµm\")^2) for l in lambda];\nr=(0:0.1:5)u\"Âµm\";\nplot(r,RIP[1].(r),label=\"Î» = 1 Âµm\",xlabel=\"r (Âµm)\",ylabel=\"Refractive index\")\nplot!(r,RIP[end].(r),label=\"Î» = 1.5 Âµm\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The modal content is then computed (note that we must use Ref(model) because length(model) is not defined in Gridap):","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model = CartesianDiscreteModel((0,20),2000)\nm=FEM1D.(lambda,[0,1,2]',RIP,Ref(model*u\"Âµm\"),neigs=2);\n#mode LP01 always exists\nneff01=[real(m[j,1][1].neff) for j in 1:length(lambda)];\nN02=sum((length.(m[:,1])).>=2);\nneff02=[real(m[j,1][2].neff) for j in 1:N02];\nN11=sum((length.(m[:,2])).>=1);\nneff11=[real(m[j,2][1].neff) for j in 1:N11];\nN21=sum((length.(m[:,3])).>=1);\nneff21=[real(m[j,3][1].neff) for j in 1:N21];\nplot(lambda,n_Ge_Doped_Silica.(lambda,0),label=\"Silica\",xlabel=\"Î»\",ylabel=\"Effective index\",color=:black);\nplot!(lambda,n_Ge_Doped_Silica.(lambda,0.2),label=\"Ge-doped Silica (20%)\",color=:black,line=:dash);\nplot!([lambda,lambda[1:N11],lambda[1:N02],lambda[1:N21]],[neff01,neff11,neff02,neff21],label=[\"LP01\" \"LP11\" \"LP02\" \"LP21\"])","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The second-order dispersion is defined by beta_2=fracpartial^2 betapartial omega^2.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"beta01=neff01*2*pi./lambda;\nomega=2*pi*OpticalFibers.PhysicalData.c_Unitful./lambda\nomega2,beta2=derivative((omega,beta01),2);\nlambda2=2*pi*OpticalFibers.PhysicalData.c_Unitful./omega2;\nplot(lambda2,uconvert.(u\"ps^2/km\",beta2),xlabel=\"Î»\",ylabel=\"Î²â‚‚\",label=\"LP01\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the effective area and the non-linear coefficient of the fundamental mode, the fields must be calculated:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m=FEM1D.(lambda,0,RIP,Ref(model*u\"Âµm\"),field=true);\nm=[m[i][1] for i in 1:length(lambda)];\nA=Aeff.(m);\ngamma=nonLinearCoefficient.(m,2.53E-20u\"m^2/W\")\nplot(lambda,A,label=\"Aeff\",ylabel=\"Effective area\",xlabel=\"Î»\",color=:blue,leg=:topright);\nplot!(twinx(),lambda,uconvert.(u\"W^-1*km^-1\",gamma),label=\"Î³\",ylabel=\"Non-linear coefficient\",color=:red,leg=:topleft)","category":"page"},{"location":"ModeSolvers-Tutorial/#Leaky-modes-in-step-index-fiber-with-a-low-index-trench","page":"ModeSolvers-Tutorial","title":"Leaky modes in step index fiber with a low index trench","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/#Circular-core","page":"ModeSolvers-Tutorial","title":"Circular core","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, we study a fiber with the parameters below:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"core with a radius of 4 Âµm and a refractive index of 1.46\na trench located between 4 Âµm and 7 Âµm with a refractive index of 1.41\na cladding with a refractive index of 1.45","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to compute the leaky scalar modes at lambda=16 Âµm, a PML must be added when using a FEM solver. In this example, the PML is located between 12 Âµm and 15 Âµm (thickness of 3 Âµm).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots, OpticalFibers, OpticalFibers.ModeSolvers\nRIP=x->1.46-0.05*(x[1]>=4u\"Âµm\")+0.04*(x[1]>7u\"Âµm\");\nmodel = CartesianDiscreteModel((0,15),1500)\nm0=FEM1D(1.6u\"Âµm\",0,RIP,model*u\"Âµm\",field=true,dPML=3u\"Âµm\",neigs=10)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The LP_01 mode is the mode 1. Since its effective index is greater than the refractive index of the cladding, this mode is guided and its losses are not significant.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The LP_02 mode is the mode 5, its losses in dB/km can be calculated:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m0[5].losses","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"r=(0:0.01:15)u\"Âµm\"\nm0=normalize.(m0)\nplot(r,real(m0[1].EMField.E(r)),xlabel=\"r\",ylabel=\"real(E)\",label=\"LP01\")\nplot!(r,-real(m0[5].EMField.E(r)),label=\"LP02\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can also compute the effective index of the LP_11 mode:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m1=FEM1D(1.6u\"Âµm\",1,RIP,model*u\"Âµm\",field=true,dPML=3u\"Âµm\",neigs=15);\npos=argmin(getproperty.(m1,:losses))\nm1[pos].neff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the four leaky vector modes that correspond to the LP_11 mode, we can also add a PML to the FEM2D solver:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model = GmshDiscreteModel(\"../../models/Step_index_fiber_pml.msh\");\nRIP2D=x->RIP(hypot(x[1],x[2]));\nm=FEM2D(1.6u\"Âµm\",RIP2D,model*u\"Âµm\",field=true,neigs=4,approx_neff=real(m1[pos].neff),dPML=3u\"Âµm\",type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The field can be plotted using GridapMakie:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapMakie, GLMakie\nfig,ax,plot_obj=GLMakie.plot(get_triangulation(m[1].EMField.Ex),real(m[1].EMField.Ex.value),axis=(aspect=DataAspect(),),colormap=:jet)\nColorbar(fig[1,2], plot_obj);\nsave(\"FEM_PML_Ex.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Real(Ex) for the first mode)","category":"page"},{"location":"ModeSolvers-Tutorial/#Elliptical-core","page":"ModeSolvers-Tutorial","title":"Elliptical core","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, the fiber is similar to the previous one but the core and the trench are elliptic:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"core with a radius of 4 Âµm in the x direction and 2 Âµm in the y direction and a refractive index of 1.46\na trench with a refractive index of 1.41 and located between the core and an ellipse with radii 8 and 4 Âµm in x and y direction respectively\na cladding with a refractive index of 1.45","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Elliptic Fiber RIP)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"A rectangular PML is added for 12vert x vert  15 Âµm and 8vert x vert  11 Âµm to compute the leaky modes.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can compute the modes in the scalar approximation or the vector modes. The results are similar since the refractive index steps are very low.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model2 = GmshDiscreteModel(\"../../models/Elliptic_fiber_rectangular_pml.msh\");\nRIP2=x->1.46-0.05*(x[1]^2/16u\"Âµm^2\"+x[2]^2/4u\"Âµm^2\">=1)+0.04*(x[1]^2/64u\"Âµm^2\"+x[2]^2/16u\"Âµm^2\">1)\nusing MUMPS\nm_scalar=FEM2D(1.6u\"Âµm\",RIP2,model2*u\"Âµm\",neigs=2,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3u\"Âµm\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m_vector=FEM2D(1.6u\"Âµm\",RIP2,model2*u\"Âµm\",neigs=4,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3u\"Âµm\",type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The first mode can be saved in a file that can be opened with ParaView:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"writevtk(\"mode1\",m_vector[1]);","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Elliptic Fiber Ex)","category":"page"},{"location":"ModeSolvers-Tutorial/#Bent-fiber","page":"ModeSolvers-Tutorial","title":"Bent fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, we will compute the bending losses of a step-index fiber at a wavelength of 1.55 Âµm. The core of the fiber has a refractive index of 1.4457 and a radius of 3.5 Âµm. The refractive index of the cladding is 1.4378.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, we can use the step-index solver to calculate the effective index. Then, the approximate formula given in the Snyder & Love [6] (Formula 23-23, page 481) can be used to compute the attenuation coefficient gamma=2*Im(beta):","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Bessels, OpticalFibers, OpticalFibers.ModeSolvers\nlambda=1.55u\"Âµm\"\nncore=1.4457\nncladding=1.4378\nrho=3.5u\"Âµm\"\ndelta=(ncore^2-ncladding^2)/(2*ncore^2)\nV=2*pi*rho/lambda*sqrt(ncore^2-ncladding^2)\nms0=multi_step_fiber_modes(lambda,0,rho,[ncore,ncladding])\nneff=ms0[1].neff\nU=2*pi*rho/lambda*sqrt(ncore^2-neff^2)\nW=2*pi*rho/lambda*sqrt(neff^2-ncladding^2)\ngamma=x->sqrt(pi)/2/rho*sqrt(rho/x)*U^2/V^2/W^(1.5)/(besselk(1,W)^2)*exp(-4/3*x/rho*W^3/V^2*delta)\nneff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute losses with FEM in the scalar approximation and neglecting the elasto-optics effect, we must add a PML and multiply the refractive index by (1+xRc) with Rc the bending radius. Note that the cladding must be large enough to contain the turning point (point at which the refractive index equals the effective index): in the case studied here, the cladding outer radius must be at least 25 Âµm for a bent radius of 10 mm. Then, we construct a model with a PML located between 32 and 35 Âµm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We first compute the effective index with the FEM2D function to check that we obtain the same value as with the step-index solver.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model = GmshDiscreteModel(\"../../models/example5.msh\");\nRIP2D=x->ncore-(ncore-ncladding)*(hypot(x[1],x[2])>=rho)\nmFEM2D=FEM2D(lambda,RIP2D,model*u\"Âµm\",field=true,neigs=1);\nneff0=mFEM2D[1].neff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we calculate modes and the attenuation coefficent for Rc between 1 and 10 mm. Note that we use threads to accelerate the computation (this is not possible when using the MUMPS solver because it uses its own threads system and this causes an error).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"RcFEM=(1:1:10)u\"mm\"\ngammaFEM=zeros(length(RcFEM))*u\"m^-1\"\nmFEM=Vector{Mode}(undef,length(RcFEM))\nThreads.@threads for i in axes(RcFEM,1)\n    RIP2D_bent=x->RIP2D(x)*(1+x[1]/RcFEM[i])\n    mFEM2D_bent=FEM2D(lambda,RIP2D_bent,model*u\"Âµm\",neigs=1,dPML=3u\"Âµm\",approx_neff=neff0,field=true);\n    mFEM[i]=mFEM2D_bent[1]\n    gammaFEM[i]=mFEM2D_bent[1].alpha;\nend\nusing Plots\nRc=(1:0.01:10)u\"mm\"\nplot(Rc,uconvert.(u\"m^-1\",gamma.(Rc)),yaxis=:log,xlabel=\"Rc\",ylabel=\"Î³\",label=\"Snyder & Love\")\nplot!(RcFEM,uconvert.(u\"m^-1\",gammaFEM),label=\"FEM2D\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The value given by FEM2D is slighlty different from that predicted by the analytical formula and the difference increases as the bent radius decreases because the mode increasingly distorted.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapMakie\nusing GLMakie\nfig=GLMakie.Figure(size=(750,250))\nfig1,ax1=GLMakie.plot(fig[1,1],get_triangulation(mFEM[10].EMField.E),abs(mFEM[10].EMField.E.value),axis=(aspect=DataAspect(),),colormap=:jet);\nfig2,ax2=GLMakie.plot(fig[1,2],get_triangulation(mFEM[3].EMField.E),abs(mFEM[3].EMField.E.value),axis=(aspect=DataAspect(),),colormap=:jet);\nfig3,ax3=GLMakie.plot(fig[1,3],get_triangulation(mFEM[1].EMField.E),abs(mFEM[1].EMField.E.value),axis=(aspect=DataAspect(),),colormap=:jet);\nfig1.title=\"Rc = 10 mm\"\nfig2.title=\"Rc = 3 mm\"\nfig3.title=\"Rc = 1 mm\"\nsave(\"Bent_fiber.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Electric field in the bent fiber)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In the case of vector modes, we can also multiply the refractive index by (1+xRc) but, more rigourously, we have to multiply the permittivity and permeability tensors by left(beginmatrix (1+xRc)  0  0\n0  (1+xRc)  0  0  0  (1+xRc)^-1 endmatrixright). Below, we compute the modes of the fiber with a bent radius of 3 mm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"R=3u\"mm\";\nepsilon2D=x->RIP2D(x)^2\neps_anisotrope=x->diagonal_tensor(VectorValue(epsilon2D(x)*(1+x[1]/R),epsilon2D(x)*(1+x[1]/R),epsilon2D(x)/(1+x[1]/R)))\nmu_anisotrope=x->diagonal_tensor(VectorValue(1+x[1]/R,1+x[1]/R,1.0/(1+x[1]/R)))\neps_anisotrope_pml=add_cylindrical_PML(eps_anisotrope,32u\"Âµm\",3u\"Âµm\",10)\nmu_anisotrope_pml=add_cylindrical_PML(mu_anisotrope,32u\"Âµm\",3u\"Âµm\",10)\nt=FEM2D_anisotropic(lambda,eps_anisotrope_pml,mu_anisotrope_pml,model*u\"Âµm\",approx_neff=neff0,neigs=2,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/#Twisted-fiber","page":"ModeSolvers-Tutorial","title":"Twisted fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The method used to compute the modes of an isotropic fiber is described in a paper written by Nicolet et al. [7]. In the following example, we use the same fiber as in the bent fiber example but instead of being bent, the fiber is twisted with a period of P=2 mm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"eps_twist=OpticalFibers.add_twist_PML(epsilon2D,2u\"mm\",32u\"Âµm\",3u\"Âµm\",10)\nmu_twist=add_twist_PML(1,2u\"mm\",32u\"Âµm\",3u\"Âµm\",10)\nusing MUMPS\nt=FEM2D_anisotropic(lambda,eps_twist,mu_twist,model*u\"Âµm\",approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Modes 2 and 20 are the HE_11 modes. The losses are not significant since the twist has no effect on a circular centered core. However, the effective indices are no more degenerate: as explained by Napiorkowski et al. [8], in the helicoidal coordinates system, the effective index is neffpmfracnu lambdaP with nu the azimuthal number (nu=1 for the HE_11 mode).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"If the core is shifted by 10 Âµm, losses due to the twist appear:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"epsilon2D_shift=x->(ncore-(ncore-ncladding)*(hypot(x[1]-10u\"Âµm\",x[2])>=rho))^2\neps_shift_twist=OpticalFibers.add_twist_PML(epsilon2D_shift,2u\"mm\",32u\"Âµm\",3u\"Âµm\",10)\nmodel_shift = GmshDiscreteModel(\"../../models/example5-decale.msh\");\nt=FEM2D_anisotropic(lambda,eps_shift_twist,mu_twist,model_shift*u\"Âµm\",approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/#Photonic-crystal-fiber-(PCF)","page":"ModeSolvers-Tutorial","title":"Photonic crystal fiber (PCF)","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In a PCF, the modes are not guided modes but leaky modes so that the computation requires a PML. The fiber is constituted of three rings of air hole (n=1) inserted in silica (n=1.45). The pitch is 2 Âµm, the hole diameter is 1.5 Âµm and the PML begins at 8 Âµm from the fiber center and its thickness is 2 Âµm. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: PCF mesh)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, the mesh is loaded:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers, OpticalFibers.ModeSolvers, GridapMakie, GLMakie\nmodel = GmshDiscreteModel(\"../../models/PCF.msh\");","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we define the refractive index profile function:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Pitch=2u\"Âµm\"\nr_hole=0.75u\"Âµm\"\npos=ring.(1:3)\nxc=vcat(first.(pos)...)*Pitch\nyc=vcat(last.(pos)...)*Pitch\nRIP_PCF(x) = (any(@. hypot(x[1]-xc,x[2]-yc)<r_hole)) ? 1.0 : 1.45","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we can compute four modes whose effective indices are close to the approximate value calculated for the fundamental mode at the wavelength of 1.3 Âµm:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"neff_approx=approx_neff_PCF(1.3u\"Âµm\",1.5u\"Âµm\",2u\"Âµm\");\nusing MUMPS\nm=FEM2D(1.3u\"Âµm\",RIP_PCF,model*u\"Âµm\",neigs=4,approx_neff=neff_approx,field=true,solver=:MUMPS,type=:Vector,dPML=2u\"Âµm\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The last two modes are fundamental modes. We can compute and plot the z-component of the Poynting vector of the last mode:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Pz=m[end].EMField.Pz\nfig,ax,plot_obj=GLMakie.plot(get_triangulation(Pz),Pz.value,axis=(aspect=DataAspect(),),colormap=:jet)\nax.xlabel=\"x (Âµm)\";\nax.ylabel=\"y (Âµm)\";\nax.title=\"neff = $(m[end].neff)\";\nColorbar(fig[1,2], plot_obj);\nsave(\"FEM2_Pz.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Pz for FM computed with FEM)","category":"page"},{"location":"ModeSolvers-Tutorial/#Photonic-bandgap-fiber","page":"ModeSolvers-Tutorial","title":"Photonic bandgap fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Before designing a PBG fiber, one has to compute the PBG of the infinite microstructured media that constitutes the cladding. In this example the cladding is a hexagonal lattice of circular rods with a pitch of 6 Âµm. The rods has a diameter of 3 Âµm and a refractive index of 1.47 while the cladding background media has a refractive index of 1.45. To compute the PBG, the mesh must be periodic. Since the cell is highly symmetric, the computation of the bands can be restricted to the highest symmetry points of the irreducible Brillouin zone (Î“, M and K).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots, OpticalFibers, OpticalFibers.ModeSolvers\nkt,weight=compute_kt(2,:Hexagon,Irreducible=true,MeshType=:Edge,Pitch=10u\"Âµm\")\nRIP2D=x->1.47-0.02*(hypot(x[1],x[2])>=3u\"Âµm\")\nmodel = GmshDiscreteModel(\"../../models/Cell_Hexagon2.msh\")\nlambda=(0.8:0.025:1.6)u\"Âµm\"\nmm=Matrix{Vector{Mode}}(undef,length(lambda),length(kt))\nThreads.@threads for i in 1:length(kt)\n    mm[:,i]=FEM2D_periodic.(lambda,RIP2D,Ref(model*u\"Âµm\"),neigs=30,field=true,kt=kt[i]);\nend\nneff=zeros(length(lambda),length(kt),30)\nP=plot()\na=palette([:red,:green,:blue],length(kt))\nplot!(P,lambda,1.45*ones(length(lambda)),color=:black,label=\"\")\nfor i=1:30\n    neff[:,:,i]=[real(m[i].neff) for m in mm]\n    for k=1:length(kt)\n        plot!(P,lambda,neff[:,k,i],color=a[k],label=\"\")\n    end\nend\nP.series_list[2].plotattributes[:label]=\"Î“\"\nP.series_list[3].plotattributes[:label]=\"M\"\nP.series_list[4].plotattributes[:label]=\"K\"\nxlabel!(\"Wavelength\")\nylabel!(\"Effective index\")\nylims!((1.43,1.47))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the fundamental mode, it is necessary to compute an approximative value of the effective index based on the band diagram.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Interpolations\nneff_approx=(max.(neff[5:18,2,7],neff[5:18,1,7])+min.(neff[5:18,2,6],1.45))/2\ninterp=LinearInterpolation(lambda[5:18],neff_approx)\nmodel_PBG = GmshDiscreteModel(\"../../models/PBG.msh\")\nPitch=10u\"Âµm\"\nr_hole=3u\"Âµm\"\npos=ring.(1:4)\nxc=vcat(first.(pos)...)*Pitch\nyc=vcat(last.(pos)...)*Pitch\nRIP_PBG(x) = (any(@. hypot(x[1]-xc,x[2]-yc)<r_hole)) ? 1.47 : 1.45\nlambda_PBG=(0.925:0.005:1.115)u\"Âµm\"\nmode_PBG=Vector{Vector{Mode}}(undef,length(lambda_PBG))\nfor i=1:length(lambda_PBG)\n    mode_PBG[i]=FEM2D(lambda_PBG[i],RIP_PBG,model_PBG*u\"Âµm\",neigs=1,approx_neff=interp(lambda_PBG[i]),field=true,solver=:MUMPS,dPML=4u\"Âµm\")\nend\nmode_PBG=vcat(mode_PBG...)\nneff_PBG=getproperty.(mode_PBG,:neff)\nAeff_PBG=Aeff.(mode_PBG)\nlosses_PBG= getproperty.(mode_PBG,:losses)\nomega=2*pi*OpticalFibers.PhysicalData.c_Unitful./lambda_PBG\nbeta=real(getproperty.(mode_PBG,:beta))\nomega2,beta2=derivative((omega,beta),2)\nlambda2=2*pi*OpticalFibers.PhysicalData.c_Unitful./omega2\np1=plot(lambda_PBG,ustrip.(losses_PBG),yaxis=:log,xlabel=\"Î»\",ylabel=\"Losses (dB/km)\")\np2=plot(lambda_PBG,Aeff_PBG,xlabel=\"Î»\",ylabel=\"Aeff\")\np3=plot(lambda2,uconvert.(u\"ps^2/km\",beta2),xlabel=\"Î»\",ylabel=\"Î²â‚‚\")\nplot(p1, p2, p3, layout=(1,3), legend=false)","category":"page"},{"location":"#OpticalFibers.jl","page":"Home","title":"OpticalFibers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers is a package that allows to compute modes of optical fibers. Different methods are implemented to find scalar or vector modes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A semi-analytical solver (based on Bessel functions) for multi-step index fibers.\nFinite element method (using Gridap.jl) for any kind of isotropic or anisotropic fiber. A PML (Perfectly Matched Layer) is implemented to compute losses of leaky modes guided in trench-assisted fibers, PCF (Photonic Crystal Fibers), bent fiber, twisted fiber, etc. The FEM mode solver can also be used to find photonic bandgaps of a PCF cladding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to specify units of physical quantities, this package uses Unitful.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers requires at least julia 1.10 and can be installed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OpticalFibers\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Finding-guided-modes-of-a-step-index-fiber-using-the-semi-analytical-mode-solver","page":"Home","title":"Finding guided modes of a step-index fiber using the semi-analytical mode solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computation of the scalar fundamental mode LP_01 of a step index fiber with a core-radius of 2 Âµm, a refractive index of 1.47 for core and 1.45 for cladding at a wavelength of 1 Âµm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OpticalFibers, OpticalFibers.ModeSolvers\njulia> ms=multi_step_fiber_modes(1u\"Âµm\",0,2u\"Âµm\",[1.47,1.45],field=true)\n1-element Vector{Mode{ScalarFiberEMField1D}}:\n [LP 0,1 - neff = 1.463179347605715 - Î» = 1 Î¼m , EMField = ScalarFiberEMField1D]\njulia> using Plots\njulia> r=(0:0.1:7)u\"Âµm\"\njulia> plot(r,abs.(ms[1].EMField.E.(r)),xlabel=\"r\",ylabel=\"|E|\",label=\"Fundamental Mode\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Step Index Fiber-FM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the fundamental vector mode HE_11 of the same fiber:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> mv=multi_step_fiber_modes(1u\"Âµm\",1,2u\"Âµm\",[1.47,1.45],type=:Vector)\n1-element Vector{Mode}:\n [HE 1,1,1.4631371608572663,1,Nothing]","category":"page"},{"location":"#Finding-guided-modes-of-a-graded-index-fiber-using-the-FEM-mode-solver","page":"Home","title":"Finding guided modes of a graded-index fiber using the FEM mode solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computation of the scalar modes of a parabolic-index fiber with a core-radius of 4 Âµm, a refractive index of 1.48 for core center and 1.45 for cladding at a wavelength of 1 Âµm by using the finite element method with 1000 nodes between r=0 and r=20 Âµm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OpticalFibers, OpticalFibers.ModeSolvers\njulia> m=FEM1D(1u\"Âµm\",0,x->1.45+0.03*(1-x[1]^2/16u\"Âµm^2\")*(x[1]<=4u\"Âµm\"),CartesianDiscreteModel((0,20),1000)*u\"Âµm\",field=true,neigs=5)\n2-element Vector{Mode{ScalarFiberEMField1D}}:\n [Mode LP nÂ°1 - neff = 1.4719806569716722 - Î» = 1 Î¼m , EMField = ScalarFiberEMField1D]\n [Mode LP nÂ°2 - neff = 1.4561502566055362 - Î» = 1 Î¼m , EMField = ScalarFiberEMField1D]\n\njulia> using Plots\njulia> r=(0:0.01:10)u\"Âµm\"\njulia> plot(r,abs2.(m[1].EMField.E(r)),label=\"LPâ‚€â‚\",xlabel=\"r\",ylabel=\"|E|Â²\")\njulia> plot!(r,abs2.(m[2].EMField.E(r)),label=\"LPâ‚€â‚‚\",xlabel=\"r\",ylabel=\"|E|Â²\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Fundamental mode example)","category":"page"},{"location":"#Finding-leaky-modes-of-a-step-index-fiber-with-a-trench-using-the-FEM-mode-solver-with-a-PML","page":"Home","title":"Finding leaky modes of a step-index fiber with a trench using the FEM mode solver with a PML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us consider a step-index fiber with a trench:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core: radius 4 Âµm and refractive index 1.44\nTrench: thickness 16 Âµm and refractive index 1.41\nCladding: refractive index 1.43","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the guided modes ell=0 without the cladding:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m=multi_step_fiber_modes(1.6u\"Âµm\",0,4u\"Âµm\",[1.44,1.41])\n2-element Vector{Mode{Nothing}}:\n [LP 0,1 - neff = 1.4345691826486056 - Î» = 1.6 Î¼m , EMField = Nothing]\n [LP 0,2 - neff = 1.4137165538840926 - Î» = 1.6 Î¼m , EMField = Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the guided modes ell=0 with the cladding:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m2=multi_step_fiber_modes(1.6u\"Âµm\",0,[4,20]u\"Âµm\",[1.44,1.41,1.43])\n1-element Vector{Mode{Nothing}}:\n [LP 0,1 - neff = 1.4345691826495002 - Î» = 1.6 Î¼m , EMField = Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"We found only one mode because the LPâ‚€â‚‚ becomes leaky when adding the cladding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute its losses, we can use the FEM solver with a PML:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> RIP_trench=x->1.44-0.03*(x[1]>=4u\"Âµm\")+0.02*(x[1]>20u\"Âµm\");\njulia> model_trench = CartesianDiscreteModel((0,50),5000)*u\"Âµm\";\njulia> ms1D_trench=FEM1D(1.6u\"Âµm\",0,RIP_trench,model_trench,field=true,dPML=5u\"Âµm\",approx_neff=m[2].neff)\n1-element Vector{Mode{ScalarFiberEMField1D}}:\n [Mode LP nÂ°1 - neff = 1.4137165449018512 + 1.0825770569064243e-8im - Î» = 1.6 Î¼m , EMField = ScalarFiberEMField1D]\njulia> ms1D_trench[1].losses\n[369.2606344137047 dB] km^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Losses of the LPâ‚€â‚‚ mode are 369 dB/km.","category":"page"},{"location":"#Finding-bend-losses-using-the-FEM-mode-solver-with-a-PML","page":"Home","title":"Finding bend losses using the FEM mode solver with a PML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us consider the step_index fiber described below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core: radius 3.5 Âµm, refractive index 1.4457\nCladding: refractive index 1.4378","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the fundamental mode at lambda=155 Âµm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ms_straight=multi_step_fiber_modes(1.55u\"Âµm\",0,3.5u\"Âµm\",[1.4457,1.4378])\n1-element Vector{Mode}:\n [LP 0,1 - neff = 1.4414392004035022 - Î» = 1.55 Î¼m , EMField = Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute the fundamental mode when the fiber is bent, we need to use a 2D mesh generated with GMSH:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> model = GmshDiscreteModel(\"./models/example5.msh\")\nInfo    : Reading './models/example5.msh'...\nInfo    : 10 entities\nInfo    : 14768 nodes\nInfo    : 29186 elements\nInfo    : Done reading './models/example5.msh'\nUnstructuredDiscreteModel()","category":"page"},{"location":"","page":"Home","title":"Home","text":"and to define the refractive index profile of the fiber bent with a radius of curvature of 10 mm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> RIP2D=x->1.4457-(1.4457-1.4378)*(hypot(x[1],x[2])>=3.5u\"Âµm\");\njulia> RIP2D_bent=x->RIP2D(x)*(1+x[1]/10u\"mm\");\njulia> ms2D_bent=FEM2D(1.55u\"Âµm\",RIP2D_bent,model*u\"Âµm\",field=true,neigs=1,dPML=3u\"Âµm\",approx_neff=ms_straight[1].neff)\n1-element Vector{Mode{ScalarFiberEMField2D}}:\n [Mode LP nÂ°1 - neff = 1.4414582242320717 + 1.5096368959603828e-9im - Î» = 1.55 Î¼m , EMField = ScalarFiberEMField2D]\njulia> ms2D_bent[1].losses\n[53.15388087039599 dB] km^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, the bend losses are 53 dB/km","category":"page"},{"location":"#Using-MUMPS-or-CUDSS-with-Mode-Solvers","page":"Home","title":"Using MUMPS or CUDSS with Mode Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The computation of modes of large microstructured fibers can take a long time (several minutes). It is possible to reduce this computation time by using the package MUMPS.jl or CUDSS.jl to speed up the LU decomposition. Note that support of CUDSS.jl is experimental because the iterative refinement tolerance is not yet implemented in CUDSS and the number of iterative refinement step has been arbitrarily set to 10. Using CUDSS requires a GPU with sufficient memory (and with good FP64 performance).","category":"page"},{"location":"","page":"Home","title":"Home","text":"On windows, recent versions of MUMPS.jl do not work and it is recommended to use version 1.4.0:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\njulia> Pkg.add(name=\"MUMPS\",version=\"1.4.0\")\njulia> Pkg.pin(\"MUMPS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The support of CUDSS.jl is restricted to version >=0.5.3","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\njulia> Pkg.add(name=\"CUDSS\",version=\"0.5.3\")\njulia> Pkg.pin(\"CUDSS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute the modes, the keyword solver must be used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MUMPS\njulia> ms2D_bent=FEM2D(1.55u\"Âµm\",RIP2D_bent,model*u\"Âµm\",field=true,neigs=1,dPML=3u\"Âµm\",approx_neff=ms_straight[1].neff,solver=:MUMPS)\n1-element Vector{Mode{ScalarFiberEMField2D}}:\n [Mode LP nÂ°1 - neff = 1.4414582242320715 + 1.5096368959671403e-9im - Î» = 1.55 Î¼m , EMField = ScalarFiberEMField2D]\njulia> using CUDSS\njulia> ms2D_bent=FEM2D(1.55u\"Âµm\",RIP2D_bent,model*u\"Âµm\",field=true,neigs=1,dPML=3u\"Âµm\",approx_neff=ms_straight[1].neff,solver=:CUDSS)\n1-element Vector{Mode{ScalarFiberEMField2D}}:\n [Mode LP nÂ°1 - neff = 1.4414582242320717 + 1.5096369002222508e-9im - Î» = 1.55 Î¼m , EMField = ScalarFiberEMField2D]","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers.jl is maintained by Olivier Vanvincq (University of Lille, PhLAM laboratory).","category":"page"},{"location":"Common/#OpticalFibers-Common-structs-and-functions","page":"Common functions","title":"OpticalFibers - Common structs and functions","text":"","category":"section"},{"location":"Common/#Convenient-functions","page":"Common functions","title":"Convenient functions","text":"","category":"section"},{"location":"Common/#OpticalFibers.piecewiseIndex","page":"Common functions","title":"OpticalFibers.piecewiseIndex","text":"piecewiseIndex(pos::T,r::Union{AbstractVector{<:T2},T2},n::AbstractVector) where {T<:Union{Real,realQuantity},T2<:Union{Real,realQuantity}}\n\nFunction that returns the refractive index at the position pos in the case of a step-index fiber profile defined by the vectors r and n.\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.meshgrid","page":"Common functions","title":"OpticalFibers.meshgrid","text":"meshgrid(v::AbstractVector)\n\nFunction equivalent to the matlab function\n\n\n\n\n\nmeshgrid(vx::AbstractVector{T}, vy::AbstractVector{T})\n\nFunction equivalent to the matlab function\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.derivative","page":"Common functions","title":"OpticalFibers.derivative","text":"derivative(t::Tuple{Vector{<:Union{Real,Quantity{<:Real}}},Vector{<:Union{Number,Quantity}}},n::Int64=1)\n\nFunction that returns the nth order derivative fracd^n xdy of the tuple t=(x,y) \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.ring","page":"Common functions","title":"OpticalFibers.ring","text":"ring(N::Integer)\n\nFunction that returns a tuple of vectors containing the coordinates (x,y) of the holes in the Nth ring of a PCF (you have to multiply by the pitch to get the real coordinates)\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.approx_nFSM_PCF","page":"Common functions","title":"OpticalFibers.approx_nFSM_PCF","text":"approx_nFSM_PCF(lambda::Real,D::Real,pitch::Real)\n\nReturns an approximate value of nFSM for photonic crystal fiber [1]  \n\nlambda: Wavelength\nD: Hole diameter\npitch: Pitch \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.approx_neff_PCF","page":"Common functions","title":"OpticalFibers.approx_neff_PCF","text":"approx_neff_PCF(lambda::Real,D::Real,pitch::Real)\n\nReturns an approximate value of the effective index of the fundamental mode of a photonic crystal fiber [1]  \n\nlambda: Wavelength\nD: Hole diameter\npitch: Pitch \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_cylindrical_PML","page":"Common functions","title":"OpticalFibers.add_cylindrical_PML","text":"add_cylindrical_PML(epsmu::Union{Number,Function},r_pml::Union{Real,realLength},d_pml::Union{Real,realLength},alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability with a cylindrical PML\n\nepsmu: permittivity/permeability profile of the fiber. The fiber is assumed to be isotropic when epsmu is a Number or a Function\nr_pml: distance between the fiber center and the PML beginning\nd_pml: PML thickness\nalphaPML: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_rectangular_PML","page":"Common functions","title":"OpticalFibers.add_rectangular_PML","text":"add_rectangular_PML(epsmu::Union{Number,Function},x_pml::Union{Real,realLength},dx_pml::Union{Real,realLength},y_pml::Union{Real,realLength},dy_pml::Union{Real,realLength},alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability with a rectangular PML located at [xpml,xpml+dxpml], [-xpml-dxpml,-xpml], [ypml,ypml+dypml], [-ypml-dypml,-ypml]\n\nepsmu: permittivity/permeability profile of the fiber. The fiber is assumed to be isotropic when epsmu is a Number or a Function\nx_pml: distance between the fiber center and the PML beginning in the x direction\ndx_pml: PML thickness in the x direction\ny_pml: distance between the fiber center and the PML beginning in the y direction\ndy_pml: PML thickness in the y direction\nalphaPML: attenuation factor of the PML\n\n\n\n\n\nadd_rectangular_PML(epsmu::Union{Number,Function},xm_pml::Union{Real,realLength},xp_pml::Union{Real,realLength},dx_pml::Union{Real,realLength},ym_pml::Union{Real,realLength},yp_pml::Union{Real,realLength},dy_pml::Union{Real,realLength},alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability with a rectangular PML located at [xppml,xppml+dxpml], [-xmpml-dxpml,-xmpml], [yppml,yppml+dypml], [-ympml-dypml,-ympml]\n\nepsmu: permittivity/permeability profile of the fiber\nxm_pml: minimum position in the x-direction of the beginning of the PML\nxp_pml: maximum position in the x-direction of the beginning of the PML\ndx_pml: PML thickness in the x direction\nym_pml: minimum position in the y-direction of the beginning of the PML\nyp_pml: maximum position in the y-direction of the beginning of the PML\ndy_pml: PML thickness in the y direction\nalphaPML: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_twist_PML","page":"Common functions","title":"OpticalFibers.add_twist_PML","text":"add_twist_PML(epsmu::Union{Number,Function},P::Union{Real,realLength},r_pml::Union{Real,realLength},d_pml::Union{Real,realLength},alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability of a twisted isotropic fiber with a cylindrical PML\n\nepsmu: function of the tuple (x,y) that describes the permittivity/permeability profile of the fiber\nP: period of the twist\nr_pml: distance between the fiber center and the PML beginning\nd_pml: PML thickness\nalpha: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.function_integrate","page":"Common functions","title":"OpticalFibers.function_integrate","text":"function_integrate(f::Function,a::AbstractVector,b::AbstractVector;kwargs...)\n\nReturns the integral int_a_1^b_1 int_a_2^b_2  f(x) dx where x is a unitless Point. The integration is performed with a change of variable x=tan(t) and the hcubature function of the Cubature.jl package.\n\na: Vector of the lower bounds of integration\nb: Vector of the upper bounds of integration\nkwargs: keyword arguments of the hcubature function (atol, rtol, initdiv, norm)\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.function_integrate_unitful","page":"Common functions","title":"OpticalFibers.function_integrate_unitful","text":"function_integrate_unitful(f::Function,a::AbstractVector,b::AbstractVector;characteristic_length::AbstractVector=[],kwargs...)\n\nReturns the integral int_a_1^b_1 int_a_2^b_2  f(x) dx where x is a Point of dimension length(a) with unit handling. The integration is performed with a change of variable x=tan(t) and the hcubature function of the Cubature.jl package.\n\na: Vector of the lower bounds of integration\nb: Vector of the upper bounds of integration\ncharacteristic_length: Vector of characteristic lengths to make the integration bounds unitless and significant variations around 1. If not provided, the unit of a is used.\nkwargs: keyword arguments of the hcubature function (atol, rtol, initdiv, norm)\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.compute_kt","page":"Common functions","title":"OpticalFibers.compute_kt","text":"compute_kt(KNumber::Int,CellType::Symbol;Irreducible::Bool=true,Pitch::Real=1,MeshType::Symbol=:Internal)\n\nCompute the vectors of a 2D Brillouin zone\n\nKNumber: Integer related to the number of vectors to compute\nCellType: :Square or :Hexagon\nIrreducible: true-> irreducible Brillouin zone, false->entire Billouin zone\npitch: Pitch \nMeshType: Internal (useful to compute the Density Of States) or :Edge (useful to compute the bandgap edge)\n\n\n\n\n\n","category":"function"}]
}
