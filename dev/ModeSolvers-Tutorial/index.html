<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModeSolvers-Tutorial · OpticalFibers.jl</title><meta name="title" content="ModeSolvers-Tutorial · OpticalFibers.jl"/><meta property="og:title" content="ModeSolvers-Tutorial · OpticalFibers.jl"/><meta property="twitter:title" content="ModeSolvers-Tutorial · OpticalFibers.jl"/><meta name="description" content="Documentation for OpticalFibers.jl."/><meta property="og:description" content="Documentation for OpticalFibers.jl."/><meta property="twitter:description" content="Documentation for OpticalFibers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpticalFibers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Common/">Common functions</a></li><li><a class="tocitem" href="../PhysicalData/">PhysicalData</a></li><li class="is-active"><a class="tocitem" href>ModeSolvers-Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Bimodal-Step-index-Fiber"><span>Bimodal Step-index Fiber</span></a></li><li><a class="tocitem" href="#Gradient-index-fiber-and-dispersion"><span>Gradient index fiber and dispersion</span></a></li><li><a class="tocitem" href="#Leaky-modes-in-step-index-fiber-with-a-low-index-trench"><span>Leaky modes in step index fiber with a low index trench</span></a></li><li><a class="tocitem" href="#Bent-fiber"><span>Bent fiber</span></a></li><li><a class="tocitem" href="#Twisted-fiber"><span>Twisted fiber</span></a></li><li><a class="tocitem" href="#Photonic-crystal-fiber-(PCF)"><span>Photonic crystal fiber (PCF)</span></a></li><li><a class="tocitem" href="#Photonic-bandgap-fiber"><span>Photonic bandgap fiber</span></a></li></ul></li><li><a class="tocitem" href="../ModeSolvers-Solvers/">ModeSolvers-Solvers</a></li><li><a class="tocitem" href="../ModeSolvers/">ModeSolvers-Modes and Fields</a></li><li><a class="tocitem" href="../Bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ModeSolvers-Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModeSolvers-Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ovanvincq/OpticalFibers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ovanvincq/OpticalFibers.jl/blob/main/docs/src/ModeSolvers-Tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OpticalFibers.ModeSolvers-Tutorial"><a class="docs-heading-anchor" href="#OpticalFibers.ModeSolvers-Tutorial">OpticalFibers.ModeSolvers - Tutorial</a><a id="OpticalFibers.ModeSolvers-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#OpticalFibers.ModeSolvers-Tutorial" title="Permalink"></a></h1><h2 id="Bimodal-Step-index-Fiber"><a class="docs-heading-anchor" href="#Bimodal-Step-index-Fiber">Bimodal Step-index Fiber</a><a id="Bimodal-Step-index-Fiber-1"></a><a class="docs-heading-anchor-permalink" href="#Bimodal-Step-index-Fiber" title="Permalink"></a></h2><p>This section explains how to modelize a step-index fiber with a core radius <span>$a=2$</span> µm. The refractive index of the core is <span>$n_{\text{core}}=1.47$</span> and that of the cladding is <span>$n_{\text{cladding}}=1.45$</span>. </p><p>This fiber is bimodal at <span>$\lambda=1$</span> µm since the normalized frequency is <span>$V=\frac{2\pi a}{\lambda}\sqrt{n_{\text{core}}^2-n_{\text{cladding}}^2}=3.04$</span>. </p><h3 id="Scalar-Modes"><a class="docs-heading-anchor" href="#Scalar-Modes">Scalar Modes</a><a id="Scalar-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Modes" title="Permalink"></a></h3><p>To compute the two scalar modes, we can use the fuction <code>multi_step_fiber_modes</code> that returns a vector of modes. The arguments are the wavelength, the azimuthal number, the radius of the core and a vector describing the refractive index. The optional argument <code>field</code> indicates that we want to return modes that contain a field.</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.ModeSolvers
m0=multi_step_fiber_modes(1,0,2,[1.47,1.45],field=true);
m01=m0[1]
m1=multi_step_fiber_modes(1,1,2,[1.47,1.45],field=true);
m11=m1[1]</code></pre><p>Note that you can also use broadcasting to compute all modes with a single command. The function <code>Ref</code> allows to use the same vector of refractive index for all values of the azimuthal number. </p><pre><code class="language-julia hljs">m=multi_step_fiber_modes.(1,[0,1],2,Ref([1.47,1.45]),field=true);
m01=m[1][1];
m11=m[2][1];</code></pre><p>The mode profile can be easily plotted by using the function <code>computeField</code></p><pre><code class="language-julia hljs">using Plots
r=0:0.01:10;
plot(r,computeField(m01,r),label=m01.Name)
plot!(r,computeField(m11,r),label=m11.Name)</code></pre><img src="e313a639.svg" alt="Example block output"/><p>In order to visualize the modes in a 2D plot, we can convert the <code>Mode{ScalarFieldFunction1D}</code> to a <code>Mode{ScalarFieldFunction2D}</code> but we have to indicate the orientation of the mode by using the <code>cos</code> function or the <code>sin</code> function. Then, we normalize the modes and plot one of the two LP<span>$_{11}$</span> modes. Be careful when using <code>Plots.jl</code>: unlike this package, the second index of the matrix corresponds to the x-coordinate (as matlab but the opposite of <code>Makie.jl</code>).</p><pre><code class="language-julia hljs">mm01=convertTo2D(m01)
mm11c=convertTo2D(m11)
mm11s=convertTo2D(m11,90)
normalize!(mm01)
normalize!(mm11c)
normalize!(mm11s)
x=-8:0.125:8;
contourf(x,x,computeField(mm11c,x,x&#39;)&#39;,levels=100,linewidth=0)</code></pre><img src="0113be01.svg" alt="Example block output"/><p>The beating between the LP<span>$_{01}$</span> and the LP<span>$_{11}$</span> can be observed by plotting the sum of the fields for different values of the distance <span>$z$</span>. The beating length is <span>$\frac{2\pi}{\vert \Delta \beta \vert} = \frac{\lambda}{\vert \Delta n_{eff} \vert}\simeq 107$</span> µm</p><pre><code class="language-julia hljs">L=1/(m01.neff-m11.neff)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">106.89413338381357</code></pre><p>We can take advantage of the possibility to add fields to create the animation.</p><pre><code class="language-julia hljs">anim=@animate for j=0:214
    TotalField=getField(mm01,j)+getField(mm11c,j);
    contourf(x,x,abs2.(computeField(TotalField,x,x&#39;))&#39;,levels=100,linewidth=0,title=&quot;z = $j µm&quot;)
end;
gif(anim,&quot;anim_field.gif&quot;,fps=15)</code></pre><img src="d35f7ea7.gif" alt="Example block output"/><h3 id="Vector-modes"><a class="docs-heading-anchor" href="#Vector-modes">Vector modes</a><a id="Vector-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-modes" title="Permalink"></a></h3><p>It is also possible to compute the vector modes of the fiber: LP<span>$_{01}$</span> mode becomes HE<span>$_{11}$</span> mode and LP<span>$_{11}$</span> mode becomes TE<span>$_{01}$</span>, TM<span>$_{01}$</span> and HE<span>$_{21}$</span> modes. To compute these modes, we just have to set the argument <code>type</code> to <code>:Vector</code> (its default value is <code>:Scalar</code>).</p><pre><code class="language-julia hljs">mv0=multi_step_fiber_modes(1,0,2,[1.47,1.45],field=true,type=:Vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{OpticalFibers.ModeSolvers.Mode}:
 [TE 0,1,1.4538242972550153,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]
 [TM 0,1,1.4537675924414297,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]</code></pre><pre><code class="language-julia hljs">mv1=multi_step_fiber_modes(1,1,2,[1.47,1.45],field=true,type=:Vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{OpticalFibers.ModeSolvers.Mode}:
 [HE 1,1b,1.4631371608572663,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]
 [HE 1,1a,1.4631371608572663,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]</code></pre><pre><code class="language-julia hljs">mv2=multi_step_fiber_modes(1,2,2,[1.47,1.45],field=true,type=:Vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{OpticalFibers.ModeSolvers.Mode}:
 [HE 2,1b,1.4537386807206427,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]
 [HE 2,1a,1.4537386807206427,1,OpticalFibers.ModeSolvers.VectorFieldFunction2D]</code></pre><p>Then, the Poynting vector of the mode HE<span>$_{21}$</span> can be computed and plotted. Since the field is described by functions, the Poynting vector components are also functions of the tuple (x,y).</p><pre><code class="language-julia hljs">Px,Py,Pz=PoyntingVector(mv2[1]);
contourf(x,x,Pz.(tuple.(x,x&#39;))&#39;,linewidth=0,levels=100,xlims=(-4,4),ylims=(-4,4))
X,Y=meshgrid(x[1:4:end]);
quiver!(X,Y,quiver=(computeField(mv2[1],x[1:4:end],x[1:4:end]&#39;,:Ex)&#39;/20,computeField(mv2[1],x[1:4:end],x[1:4:end]&#39;,:Ey)&#39;/20),color=:cyan,arrow=arrow(:closed))</code></pre><img src="765cb305.svg" alt="Example block output"/><p>In order to check the orthoganality of the modes, we can normalize them and compute the overlap integrals. Note that in the case of functions, there are two optionnal arguments for the function <code>overlap</code>: <code>rtol</code> (relative tolerance) and <code>atol</code> (absolute tolerance). These tolerances are used to compute the integrals with the package <code>HCubature</code>. Here, we know that the integrals are very small in the case of two orthogonal modes so that the relative tolerance on the overlap integral cannot be reached because of Bessel function precision. This is why we have imposed an absolute tolerance of 1E-15.</p><pre><code class="language-julia hljs">mv=[mv1;mv0;mv2];
normalize!.(mv,atol=1E-5);
overlap.(mv,transpose(mv),atol=1E-15,rtol=1E-5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 Matrix{Float64}:
 1.00001       7.81483e-21   5.0356e-18   …   1.59824e-16   5.063e-18
 7.81483e-21   1.00001      -1.59789e-16      3.36176e-17   5.063e-18
 5.09221e-18  -8.24688e-17   1.0             -3.26602e-18   2.73744e-16
 5.02131e-18   5.02131e-18   4.6296e-37      -2.05307e-16  -3.22067e-18
 5.06946e-18  -5.06946e-18  -3.22937e-18      0.999999      1.24948e-21
 5.06382e-18   5.06382e-18   1.36872e-16  …   1.24948e-21   1.0</code></pre><h3 id="Scalar-modes-with-FEM1D"><a class="docs-heading-anchor" href="#Scalar-modes-with-FEM1D">Scalar modes with FEM1D</a><a id="Scalar-modes-with-FEM1D-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-modes-with-FEM1D" title="Permalink"></a></h3><p>We can find the results above using the FEM method. We will start with the 1D method since the fiber has a cylindrical symmetry. The mesh must begin at <span>$r=0$</span> and we have set its end at 15 µm. The number of elements is set to 1500. The FEM computation functions require the relative permittivity i.e. the square of the refractive index. We indicate to the the FEM solver that we want to compute 4 eigenvalues but it returns only one since there is only one mode for <span>$\ell=0$</span>.</p><pre><code class="language-julia hljs">using Gridap
model = CartesianDiscreteModel((0,15),1500)
epsilon=x-&gt;(1.47-0.02*(x[1]&gt;=2))^2
m0FEM=FEM1D(1,0,epsilon,model,field=true,neigs=4)
normalize!(m0FEM[1])
normalize!(m0[1])
r=0:0.01:10
plot(r,computeField(m0[1],r),label=&quot;Step-index solver&quot;)
plot!(r,-real(computeField(m0FEM[1],r)),label=&quot;FEM1D solver&quot;,line=:dash)</code></pre><img src="cd3c1f54.svg" alt="Example block output"/><h3 id="Scalar-modes-with-FEM2D"><a class="docs-heading-anchor" href="#Scalar-modes-with-FEM2D">Scalar modes with FEM2D</a><a id="Scalar-modes-with-FEM2D-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-modes-with-FEM2D" title="Permalink"></a></h3><p>We can also use the FEM2D method. For this, we use a mesh created with GMSH and a function of the tuple <span>$(x,y)$</span> that describes the permittivity. We ask the solver to find 4 modes but it returns only 3 because the fiber can only guides the modes LP01, LP11a and LP11b (a and b refer to the orientation of the mode).</p><pre><code class="language-julia hljs">using GridapGmsh
model = GmshDiscreteModel(&quot;../../models/example1.msh&quot;);
epsilon2D=x-&gt;(1.47-0.02*(hypot(x[1],x[2])&gt;=2))^2
mFEM2D=FEM2D(1,epsilon2D,model,field=true,neigs=4)
normalize!.(mFEM2D)
p1=contourf(x,x,real(computeField(mFEM2D[1],x,x&#39;))&#39;,levels=50,linewidth=0,aspect_ratio=:equal);
p2=contourf(x,x,real(computeField(mFEM2D[2],x,x&#39;))&#39;,levels=50,linewidth=0,aspect_ratio=:equal);
p3=contourf(x,x,real(computeField(mFEM2D[3],x,x&#39;))&#39;,levels=50,linewidth=0,aspect_ratio=:equal);
plot(p1, p2, p3, layout=(1,3), legend=false,size=(900,300))</code></pre><img src="0f760d76.svg" alt="Example block output"/><pre><code class="language-julia hljs">abs2.(overlap.(mFEM2D,[mm01 mm11c mm11s]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 1.0          4.74343e-16  2.4216e-16
 5.98267e-18  0.254676     0.745311
 7.08589e-16  0.748057     0.251931</code></pre><h3 id="Vector-modes-with-FEM2D"><a class="docs-heading-anchor" href="#Vector-modes-with-FEM2D">Vector modes with FEM2D</a><a id="Vector-modes-with-FEM2D-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-modes-with-FEM2D" title="Permalink"></a></h3><p>To compute the vector, we just have to set <code>type</code> to <code>:Vector</code>. We ask the solver to find 8 modes but it returns only 6 because the fiber can only guides 2 modes HE<span>$_{11}$</span>, 1 mode becomes TE<span>$_{01}$</span>, 1 mode TM<span>$_{01}$</span> and 2 modes HE<span>$_{21}$</span>. </p><pre><code class="language-julia hljs">mvFEM2D=FEM2D(1,epsilon2D,model,field=true,neigs=8,type=:Vector)
normalize!.(mvFEM2D)
abs2.(overlap.(mvFEM2D,transpose(mv)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 Matrix{Float64}:
 0.575075     0.424927     9.57897e-18  3.58067e-18  9.00965e-20  9.17461e-19
 0.418078     0.581924     5.23227e-21  2.68409e-20  4.26933e-21  1.38206e-20
 1.10825e-21  1.06293e-20  0.999992     1.51833e-16  6.36074e-16  2.27067e-19
 1.07988e-20  8.86541e-21  6.84851e-17  0.999992     9.11307e-16  1.28232e-14
 2.10888e-20  1.51846e-21  1.11926e-16  9.77668e-15  0.643235     0.356756
 1.4038e-21   1.08295e-20  2.70289e-16  1.16973e-14  0.150545     0.849446</code></pre><p>In addition to the computation of the overlaps, we can verify that the modes given by the quasi-analytical solver and the FEM solver are the same by plotting the fields.</p><pre><code class="language-julia hljs">p1=contourf(x,x,real(computeField(mvFEM2D[4],x,x&#39;,:Ex))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ex&quot;);
p2=contourf(x,x,real(computeField(mvFEM2D[4],x,x&#39;,:Ey))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ey&quot;);
p3=contourf(x,x,imag(computeField(mvFEM2D[4],x,x&#39;,:Ez))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ez&quot;);
p4=contourf(x,x,real(computeField(mvFEM2D[4],x,x&#39;,:Hx))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hx&quot;);
p5=contourf(x,x,real(computeField(mvFEM2D[4],x,x&#39;,:Hy))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hy&quot;);
p6=contourf(x,x,imag(computeField(mvFEM2D[4],x,x&#39;,:Hz))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hz&quot;);
plot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))</code></pre><img src="35b9bb33.svg" alt="Example block output"/><pre><code class="language-julia hljs">p1=contourf(x,x,real(computeField(mv[4],x,x&#39;,:Ex))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ex&quot;);
p2=contourf(x,x,real(computeField(mv[4],x,x&#39;,:Ey))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ey&quot;);
p3=contourf(x,x,imag(computeField(mv[4],x,x&#39;,:Ez))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Ez&quot;);
p4=contourf(x,x,real(computeField(mv[4],x,x&#39;,:Hx))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hx&quot;);
p5=contourf(x,x,real(computeField(mv[4],x,x&#39;,:Hy))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hy&quot;);
p6=contourf(x,x,imag(computeField(mv[4],x,x&#39;,:Hz))&#39;,levels=50,linewidth=0,aspect_ratio=:equal,title=&quot;Hz&quot;);
plot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))</code></pre><img src="67c51089.svg" alt="Example block output"/><h2 id="Gradient-index-fiber-and-dispersion"><a class="docs-heading-anchor" href="#Gradient-index-fiber-and-dispersion">Gradient index fiber and dispersion</a><a id="Gradient-index-fiber-and-dispersion-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-index-fiber-and-dispersion" title="Permalink"></a></h2><p>In this tutorial, a germanium-doped parabolic gradient index fiber will be studied. The maximum Ge concentration is 20% and the core radius is 3.5 µm. The silica dispersion will be taken into account.</p><p>First, a vector of <code>Function</code> is created to modelized the dispersive refractive index profile between 1 and 1.5 µm:</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.PhysicalData
using Plots
lambda=1:0.01:1.5;
epsilon=[x-&gt;(n_Ge_Doped_Silica(l*1e-6,0)+(n_Ge_Doped_Silica(l*1e-6,0.2)-n_Ge_Doped_Silica(l*1e-6,0))*(x[1]&lt;=3.5)*(1-x[1]^2/3.5^2))^2 for l in lambda];
r=0:0.1:5;
plot(r,sqrt.(epsilon[1].(r)),label=&quot;λ = 1 µm&quot;,xlabel=&quot;r (µm)&quot;,ylabel=&quot;Refractive index&quot;);
plot!(r,sqrt.(epsilon[end].(r)),label=&quot;λ = 1.5 µm&quot;)</code></pre><img src="141441a0.svg" alt="Example block output"/><p>The modal content is then computed (note that we must use Ref(model) because length(model) is not defined in Gridap):</p><pre><code class="language-julia hljs">using OpticalFibers.ModeSolvers
using Gridap
model = CartesianDiscreteModel((0,20),2000)
m=FEM1D.(lambda,[0,1,2]&#39;,epsilon,Ref(model),neigs=2);
#mode LP01 always exists
neff01=[real(m[j,1][1].neff) for j in 1:length(lambda)];
N02=sum((length.(m[:,1])).&gt;=2);
neff02=[real(m[j,1][2].neff) for j in 1:N02];
N11=sum((length.(m[:,2])).&gt;=1);
neff11=[real(m[j,2][1].neff) for j in 1:N11];
N21=sum((length.(m[:,3])).&gt;=1);
neff21=[real(m[j,3][1].neff) for j in 1:N21];
plot(lambda,n_Ge_Doped_Silica.(lambda*1E-6,0),label=&quot;Silica&quot;,xlabel=&quot;λ (µm)&quot;,ylabel=&quot;Effective index&quot;,color=:black);
plot!(lambda,n_Ge_Doped_Silica.(lambda*1E-6,0.2),label=&quot;Ge-doped Silica (20%)&quot;,color=:black,line=:dash);
plot!([lambda,lambda[1:N11],lambda[1:N02],lambda[1:N21]],[neff01,neff11,neff02,neff21],label=[&quot;LP01&quot; &quot;LP11&quot; &quot;LP02&quot; &quot;LP21&quot;])</code></pre><img src="8c0d7f94.svg" alt="Example block output"/><p>The second-order dispersion is defined by <span>$\beta_2=\frac{\partial^2 \beta}{\partial \omega^2}$</span>.</p><pre><code class="language-julia hljs">beta01=neff01*2*pi./lambda*1E6;
omega=2*pi*OpticalFibers.PhysicalData.c./lambda*1E6;
omega2,beta2=derivative((omega,beta01),2);
lambda2=2*pi*OpticalFibers.PhysicalData.c./omega2*1E6;
plot(lambda2,beta2*1E26,xlabel=&quot;λ (µm)&quot;,ylabel=&quot;β₂ (10⁻²⁶ s²/m)&quot;,label=&quot;LP01&quot;)</code></pre><img src="8cbabdbc.svg" alt="Example block output"/><p>To compute the effective area and the non-linear coefficient of the fundamental mode, the fields must be calculated:</p><pre><code class="language-julia hljs">m=FEM1D.(lambda,0,epsilon,Ref(model),field=true);
m=[m[i][1] for i in 1:length(lambda)];
A=Aeff.(m);
gamma=nonLinearCoefficient.(m,2.53E-20)*1E21;
plot(lambda,A,label=&quot;Aeff&quot;,ylabel=&quot;Effective area (µm²)&quot;,xlabel=&quot;λ (µm)&quot;,color=:blue,leg=:topright);
plot!(twinx(),lambda,gamma,label=&quot;γ&quot;,ylabel=&quot;Non-linear coefficient ((W.km)⁻¹)&quot;,color=:red,leg=:topleft)</code></pre><img src="59f45a6c.svg" alt="Example block output"/><h2 id="Leaky-modes-in-step-index-fiber-with-a-low-index-trench"><a class="docs-heading-anchor" href="#Leaky-modes-in-step-index-fiber-with-a-low-index-trench">Leaky modes in step index fiber with a low index trench</a><a id="Leaky-modes-in-step-index-fiber-with-a-low-index-trench-1"></a><a class="docs-heading-anchor-permalink" href="#Leaky-modes-in-step-index-fiber-with-a-low-index-trench" title="Permalink"></a></h2><h3 id="Circular-core"><a class="docs-heading-anchor" href="#Circular-core">Circular core</a><a id="Circular-core-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-core" title="Permalink"></a></h3><p>In this example, we study a fiber with the parameters below:</p><ul><li>core with a radius of 4 µm and a refractive index of 1.46</li><li>a trench located between 4 µm and 7 µm with a refractive index of 1.41</li><li>a cladding with a refractive index of 1.45</li></ul><p>In order to compute the leaky scalar modes at <span>$\lambda=1.6$</span> µm, a PML must be added when using a FEM solver. In this example, the PML is located between 12 µm and 15 µm (thickness of 3 µm).</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.ModeSolvers
using Gridap
epsilon=x-&gt;(1.46-0.05*(x[1]&gt;=4)+0.04*(x[1]&gt;7))^2;
model = CartesianDiscreteModel((0,15),1500)
m0=FEM1D(1.6,0,epsilon,model,field=true,dPML=3,neigs=10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.ScalarFieldFEM1D}}:
 [Mode LP n°1,1.4541423643306999 + 6.314171957490049e-10im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°2,1.4531730732044525 + 0.0039923612485313325im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°3,1.4502897353690325 + 0.0006416936437411575im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°4,1.4448408141094689 + 0.005072664092572169im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°5,1.4299693817878352 + 3.863247392720245e-5im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°6,1.4284719092257003 + 0.012230052005964567im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°7,1.4003435812932843 + 0.01808599747954087im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°8,1.4600349020404593 + 0.010181223518781087im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°9,1.485388484408587 + 0.029091841125400718im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]
 [Mode LP n°10,1.470807939791444 + 0.018594353667345163im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM1D]</code></pre><p>The LP<span>$_{01}$</span> mode is the mode 1. Since its effective index is greater than the refractive index of the cladding, this mode is guided and its losses are not significant.</p><p>The LP<span>$_{02}$</span> mode is the mode 5, its losses in dB/km can be calculated:</p><pre><code class="language-julia hljs">losses(m0[5])*1e6</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.3177308479171616e6</code></pre><pre><code class="language-julia hljs">using Plots
r=0:0.01:15
normalize!.(m0)
plot(r,real.(computeField(m0[1],r)),xlabel=&quot;r (µm)&quot;,ylabel=&quot;real(E)&quot;,label=&quot;LP01&quot;)
plot!(r,-real.(computeField(m0[5],r)),label=&quot;LP02&quot;)</code></pre><img src="9c6436da.svg" alt="Example block output"/><p>We can also compute the effective index of the LP<span>$_{11}$</span> mode:</p><pre><code class="language-julia hljs">m1=FEM1D(1.6,1,epsilon,model,field=true,dPML=3,neigs=15);
pos=argmin(losses.(m1)*1E6);
m1[pos].neff</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.4452245032447497 + 2.3860418912287596e-6im</code></pre><p>To compute the leaky vector modes that correspond to the LP<span>$_{11}$</span> mode, we can also add a PML to the FEM2D solver:</p><pre><code class="language-julia hljs">using Gridap
using GridapGmsh
model = GmshDiscreteModel(&quot;../../models/Step_index_fiber_pml.msh&quot;);
epsilon2D=x-&gt;epsilon(hypot(x[1],x[2]));
m=FEM2D(1.6,epsilon2D,model,field=true,neigs=4,approx_neff=real(m1[pos].neff),dPML=3,type=:Vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4452006565798403 + 2.3754864202395263e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4450417028545304 + 2.377089631823041e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°3,1.4450417027953408 + 2.377089601746072e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°4,1.4449793153895623 + 2.351368177559788e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><p>The field can be plotted using GridapMakie:</p><pre><code class="language-julia hljs">using GridapMakie
using GLMakie
fig,ax,plot_obj=GLMakie.plot(get_triangulation(m[1]),real(m[1].field.Ex),axis=(aspect=DataAspect(),),colormap=:jet)
Colorbar(fig[1,2], plot_obj);</code></pre><p><img src="../FEM_PML_Ex.png" alt="Real(Ex) for the first mode"/></p><h3 id="Elliptical-core"><a class="docs-heading-anchor" href="#Elliptical-core">Elliptical core</a><a id="Elliptical-core-1"></a><a class="docs-heading-anchor-permalink" href="#Elliptical-core" title="Permalink"></a></h3><p>In this example, the fiber is similar to the previous one but the core and the trench are elliptic:</p><ul><li>core with a radius of 4 µm in the x direction and 2 µm in the y direction and a refractive index of 1.46</li><li>a trench with a refractive index of 1.41 and located between the core and an ellipse with radii 8 and 4 µm in x and y direction respectively</li><li>a cladding with a refractive index of 1.45</li></ul><p><img src="../assets/Elliptic_profile.png" alt="Elliptic Fiber RIP"/></p><p>A rectangular PML is added for <span>$12&lt;\vert x \vert &lt; 15$</span> µm and <span>$8&lt;\vert x \vert &lt; 11$</span> µm to compute the leaky modes.</p><p>We can compute the modes in the scalar approximation or the vector modes. The results are similar since the refractive index steps are very low.</p><pre><code class="language-julia hljs">model2 = GmshDiscreteModel(&quot;../../models/Elliptic_fiber_rectangular_pml.msh&quot;);
epsilon2=x-&gt;(1.46-0.05*(x[1]^2/16+x[2]^2/4&gt;=1)+0.04*(x[1]^2/64+x[2]^2/16&gt;1))^2
m_scalar=FEM2D(1.6,epsilon2,model2,neigs=2,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.ScalarFieldFEM2D}}:
 [Mode LP n°1,1.4384991364326472 + 3.7131706724882447e-5im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM2D]
 [Mode LP n°2,1.4484506053967627 + 8.55723850635876e-6im,1.6,OpticalFibers.ModeSolvers.ScalarFieldFEM2D]</code></pre><pre><code class="language-julia hljs">m_vector=FEM2D(1.6,epsilon2,model2,neigs=4,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3,type=:Vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4383475195686846 + 3.788502410046275e-5im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4381599700049013 + 3.7881412649185715e-5im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°3,1.4483977879498438 + 8.758494190945846e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°4,1.4481707582287962 + 9.435653061995813e-6im,1.6,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><p>The first mode can be saved in a file that can be opened with ParaView:</p><pre><code class="language-julia hljs">writevtk(&quot;mode1&quot;,m_vector[1]);</code></pre><p><img src="../assets/Elliptic_Ex.png" alt="Elliptic Fiber Ex"/></p><h2 id="Bent-fiber"><a class="docs-heading-anchor" href="#Bent-fiber">Bent fiber</a><a id="Bent-fiber-1"></a><a class="docs-heading-anchor-permalink" href="#Bent-fiber" title="Permalink"></a></h2><p>In this example, we will compute the bending losses of a step-index fiber at a wavelength of 1.55 µm. The core of the fiber has a refractive index of 1.4457 and a radius of 3.5 µm. The refractive index of the cladding is 1.4378.</p><p>First, we can use the step-index solver to calculate the effective index. Then, the approximate formula given in the Snyder &amp; Love [<a href="../Bibliography/#SnyderLove:1983">6</a>] (Formula 23-23, page 481) can be used to compute the attenuation coefficient <span>$\gamma=2*Im(\beta)$</span>:</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.ModeSolvers
using Bessels
lambda=1.55
ncore=1.4457
ncladding=1.4378
rho=3.5
delta=(ncore^2-ncladding^2)/(2*ncore^2)
V=2*pi*rho/lambda*sqrt(ncore^2-ncladding^2)
ms0=multi_step_fiber_modes(lambda,0,rho,[ncore,ncladding])
neff=ms0[1].neff
U=2*pi*rho/lambda*sqrt(ncore^2-neff^2)
W=2*pi*rho/lambda*sqrt(neff^2-ncladding^2)
gamma=x-&gt;sqrt(pi)/2/(rho*1E-6)*sqrt(rho*1E-6/x)*U^2/V^2/W^(1.5)/(besselk(1,W)^2)*exp(-4/3*x/(rho*1E-6)*W^3/V^2*delta)
neff</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.4414392004035022</code></pre><p>To compute losses with FEM in the scalar approximation and neglecting the elasto-optics effect, we must add a PML and multiply the refractive index by <span>$(1+x/Rc)$</span> with <span>$Rc$</span> the bending radius. Note that the cladding must be large enough to contain the turning point (point at which the refractive index equals the effective index): in the case studied here, the cladding outer radius must be at least 25 µm for a bent radius of 10 mm. Then, we construct a model with a PML located between 32 and 35 µm.</p><p>We first compute the effective index with the FEM2D function to check that we obtain the same value as with the step-index solver.</p><pre><code class="language-julia hljs">using GridapGmsh
model = GmshDiscreteModel(&quot;../../models/example5.msh&quot;);
epsilon2D=x-&gt;(ncore-(ncore-ncladding)*(hypot(x[1],x[2])&gt;=rho))^2
mFEM2D=FEM2D(lambda,epsilon2D,model,field=true,neigs=1);
neff0=mFEM2D[1].neff</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.4414375200134855</code></pre><p>Then we calculate modes and the attenuation coefficent for Rc between 1 and 10 mm. Note that we use threads to accelerate the computation (this is not possible when using the MUMPS solver because it uses its own threads system and this causes an error).</p><pre><code class="language-julia hljs">RcFEM=1:1:10
gammaFEM=zeros(length(RcFEM))
mFEM=Vector{Mode}(undef,length(RcFEM))
Threads.@threads for i in axes(RcFEM,1)
    epsilon2D_bent=x-&gt;epsilon2D(x)*(1+x[1]/RcFEM[i]*1E-3)^2
    mFEM2D_bent=FEM2D(lambda,epsilon2D_bent,model,neigs=1,dPML=3,approx_neff=neff0,field=true);
    mFEM[i]=mFEM2D_bent[1]
    gammaFEM[i]=2*imag(2*pi*mFEM2D_bent[1].neff/(lambda*1E-6))
end
using Plots
Rc=1:0.01:10
plot(Rc,gamma.(Rc*1E-3),yaxis=:log,xlabel=&quot;Rc (mm)&quot;,ylabel=&quot;γ (m⁻¹)&quot;,label=&quot;Snyder &amp; Love&quot;)
plot!(RcFEM,gammaFEM,label=&quot;FEM2D&quot;)</code></pre><img src="68d03e76.svg" alt="Example block output"/><p>The value given by FEM 2D is slighlty different from that predicted by the analytical formula and the difference increases as the bent radius decreases because the mode increasingly distorted.</p><pre><code class="language-julia hljs">using GridapMakie
using GLMakie
using Gridap
fig=GLMakie.Figure(size=(750,250))
fig1,ax1=GLMakie.plot(fig[1,1],get_triangulation(mFEM[10]),abs(mFEM[10].field.E),axis=(aspect=DataAspect(),),colormap=:jet);
fig2,ax2=GLMakie.plot(fig[1,2],get_triangulation(mFEM[3]),abs(mFEM[3].field.E),axis=(aspect=DataAspect(),),colormap=:jet);
fig3,ax3=GLMakie.plot(fig[1,3],get_triangulation(mFEM[1]),abs(mFEM[1].field.E),axis=(aspect=DataAspect(),),colormap=:jet);
fig1.title=&quot;Rc = 10 mm&quot;
fig2.title=&quot;Rc = 3 mm&quot;
fig3.title=&quot;Rc = 1 mm&quot;</code></pre><p><img src="../Bent_fiber.png" alt="Electric field in the bent fiber"/></p><p>In the case of vector modes, we can also multiply the refractive index by <span>$(1+x/Rc)$</span> but, more rigourously, we have to multiply the permittivity and permeability tensors by <span>$\left(\begin{matrix} (1+x/Rc) &amp; 0 &amp; 0\\
0 &amp; (1+x/Rc) &amp; 0 \\ 0 &amp; 0 &amp; (1+x/Rc)^{-1} \end{matrix}\right)$</span>. Below, we compute the modes of the fiber with a bent radius of 3 mm.</p><pre><code class="language-julia hljs">R=3E3;
eps_anisotrope=tensor3(x-&gt;epsilon2D(x)*(1+x[1]/R),x-&gt;epsilon2D(x)*(1+x[1]/R),x-&gt;epsilon2D(x)/(1+x[1]/R))
mu_anisotrope=tensor3(x-&gt;(1+x[1]/R),x-&gt;(1+x[1]/R),x-&gt;1.0/(1+x[1]/R))
eps_anisotrope_pml=add_cylindrical_PML(eps_anisotrope,32,3,10)
mu_anisotrope_pml=add_cylindrical_PML(mu_anisotrope,32,3,10)
t=FEM2D_anisotropic(lambda,eps_anisotrope_pml,mu_anisotrope_pml,model,approx_neff=neff0,neigs=2,field=true,solver=:MUMPS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4416768654245808 + 3.6042924309393196e-5im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4416765907587341 + 3.5989625026279224e-5im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><h2 id="Twisted-fiber"><a class="docs-heading-anchor" href="#Twisted-fiber">Twisted fiber</a><a id="Twisted-fiber-1"></a><a class="docs-heading-anchor-permalink" href="#Twisted-fiber" title="Permalink"></a></h2><p>The method used to compute the modes of an isotropic fiber is described in a paper written by Nicolet et al. [<a href="../Bibliography/#Nicolet2007">7</a>]. In the following example, we use the same fiber as in the bent fiber example but instead of being bent, the fiber is twisted with a period of <span>$P=2$</span> mm.</p><pre><code class="language-julia hljs">eps_twist=OpticalFibers.add_twist_PML(epsilon2D,2E3,32,3,10)
mu_twist=add_twist_PML(1,2E3,32,3,10)
t=FEM2D_anisotropic(lambda,eps_twist,mu_twist,model,approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4411165490874729 + 0.0003465626588228148im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4406496405663145 - 9.077417076084825e-15im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°3,1.4405163236760896 + 0.00023801519220013447im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°4,1.4406255551855576 + 0.000649772309859767im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°5,1.4401140227767457 + 0.00048615788483628804im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°6,1.4398854924770579 + 0.00014844245789050143im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°7,1.439568953218554 + 0.0003431583754194512im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°8,1.440174068237496 + 0.0009292778487510783im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°9,1.4397312480683486 + 0.0007234331975607218im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°10,1.4405825376751105 + 0.0011562173725928955im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°11,1.4411042672066874 + 0.0008339787182464823im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°12,1.4409570383007555 + 0.0014037004367457397im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°13,1.4412975936624224 + 0.0016711431324053165im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°14,1.4415506886610872 + 0.0010384201281191724im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°15,1.441965196452513 + 0.0012627588926876706im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°16,1.4423480209362722 + 0.001506673694069156im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°17,1.442737547886057 + 0.0007841674602818648im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°18,1.442226871954087 + 0.0006198104739277073im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°19,1.4416866221114484 + 0.0004738924706385127im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°20,1.44220233590338 - 5.579597837240603e-15im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><p>Modes 2 and 20 are the HE<span>$_{11}$</span> modes. The losses are not significant since the twist has no effect on a circular centered core. However, the effective indices are no more degenerate: as explained by Napiorkowski et al. [<a href="../Bibliography/#Napiorkowski:2014">8</a>], in the helicoidal coordinates system, the effective index is neff<span>$\pm\frac{\nu \lambda}{P}$</span> with <span>$\nu$</span> the azimuthal number (<span>$\nu=1$</span> for the HE<span>$_{11}$</span> mode).</p><p>If the core is shifted by 10 µm, losses due to the twist appear:</p><pre><code class="language-julia hljs">epsilon2D_shift=x-&gt;(ncore-(ncore-ncladding)*(hypot(x[1]-10,x[2])&gt;=rho))^2
eps_shift_twist=OpticalFibers.add_twist_PML(epsilon2D_shift,2E3,32,3,10)
model_shift = GmshDiscreteModel(&quot;../../models/example5-decale.msh&quot;);
t=FEM2D_anisotropic(lambda,eps_shift_twist,mu_twist,model_shift,approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4413791031947052 + 1.86455629554845e-8im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4411167443888035 + 0.0003469989946093466im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°3,1.4405165932628623 + 0.0002395817085328868im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°4,1.440624302429853 + 0.0006522070063221269im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°5,1.440110819358105 + 0.0004923274816631669im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°6,1.439884889437539 + 0.00015382690526603499im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°7,1.4395599274028406 + 0.00036020609781143117im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°8,1.4401630663790501 + 0.0009345280162899101im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°9,1.4397069620015577 + 0.0007349498803109592im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°10,1.4405777402838238 + 0.001159511285937519im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°11,1.4411038295387892 + 0.0008350868659750683im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°12,1.4409553553667067 + 0.0014056422106930005im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°13,1.4412971882000583 + 0.001672078425000286im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°14,1.4415505984109342 + 0.0010389119353283662im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°15,1.4419652051335825 + 0.0012629460340890944im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°16,1.4423480384331246 + 0.0015067320573145615im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°17,1.4427375580235746 + 0.0007841853104812542im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°18,1.442931783043756 + 1.8412183496366715e-8im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°19,1.4422269102647611 + 0.0006198605033307664im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°20,1.4416867144009204 + 0.00047402872700327283im,1.55,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><h2 id="Photonic-crystal-fiber-(PCF)"><a class="docs-heading-anchor" href="#Photonic-crystal-fiber-(PCF)">Photonic crystal fiber (PCF)</a><a id="Photonic-crystal-fiber-(PCF)-1"></a><a class="docs-heading-anchor-permalink" href="#Photonic-crystal-fiber-(PCF)" title="Permalink"></a></h2><p>In a PCF, the modes are not guided modes but leaky modes so that the computation requires a PML. The fiber is constituted of three rings of air hole (n=1) inserted in silica (n=1.45). The pitch is 2 µm, the hole diameter is 1.5 µm and the PML begins at 8 µm from the fiber center and its thickness is 2 µm. </p><p><img src="../assets/PCF.png" alt="PCF mesh"/></p><p>First, the mesh is loaded:</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.ModeSolvers
using Gridap
using GridapGmsh
using GridapMakie
using GLMakie
model = GmshDiscreteModel(&quot;../../models/PCF.msh&quot;);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnstructuredDiscreteModel()</code></pre><p>Then we define the permittivity function:</p><pre><code class="language-julia hljs">Pitch=2
r_hole=0.75
pos=ring.(1:3)
xc=vcat(first.(pos)...)*Pitch
yc=vcat(last.(pos)...)*Pitch
eps_PCF(x) = (any(@. hypot(x[1]-xc,x[2]-yc)&lt;r_hole)) ? 1.0 : 1.45^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">eps_PCF (generic function with 1 method)</code></pre><p>Then we can compute four modes whose effective indices are close to the approximate value calculated for the fundamental mode at the wavelength of 1.3 µm:</p><pre><code class="language-julia hljs">neff_approx=approx_neff_PCF(1.3,1.5,2);
m=FEM2D(1.3,eps_PCF,model,neigs=4,approx_neff=neff_approx,field=true,solver=:MUMPS,type=:Vector,dPML=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{OpticalFibers.ModeSolvers.Mode{OpticalFibers.ModeSolvers.VectorFieldFEM2D}}:
 [Mode n°1,1.4228684479021072 + 0.022503969544686912im,1.3,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°2,1.4228715121529298 + 0.022503389038715252im,1.3,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°3,1.4134836231922743 + 4.349480873781414e-14im,1.3,OpticalFibers.ModeSolvers.VectorFieldFEM2D]
 [Mode n°4,1.4134823818566962 + 4.353797306513146e-14im,1.3,OpticalFibers.ModeSolvers.VectorFieldFEM2D]</code></pre><p>The last two modes are fundamental modes. We can compute and plot the z-component of the Poynting vector of the last mode:</p><pre><code class="language-julia hljs">Px,Py,Pz=PoyntingVector(m[end]);
fig,ax,plot_obj=GLMakie.plot(get_triangulation(Pz),Pz,axis=(aspect=DataAspect(),),colormap=:jet)
ax.xlabel=&quot;x (µm)&quot;;
ax.ylabel=&quot;y (µm)&quot;;
ax.title=&quot;neff = $(m[end].neff)&quot;;
Colorbar(fig[1,2], plot_obj);</code></pre><p><img src="../FEM2_Pz.png" alt="Pz for FM computed with FEM"/></p><h2 id="Photonic-bandgap-fiber"><a class="docs-heading-anchor" href="#Photonic-bandgap-fiber">Photonic bandgap fiber</a><a id="Photonic-bandgap-fiber-1"></a><a class="docs-heading-anchor-permalink" href="#Photonic-bandgap-fiber" title="Permalink"></a></h2><p>Before designing a PBG fiber, one has to compute the PBG of the infinite microstructured media that constitutes the cladding. In this example the cladding is a hexagonal lattice of circular rods with a pitch of 6 µm. The rods has a diameter of 3 µm and a refractive index of 1.47 while the cladding background media has a refractive index of 1.45. To compute the PBG, the mesh must be periodic. Since the cell is highly symmetric, the computation of the bands can be restricted to the highest symmetry points of the irreducible Brillouin zone (Γ, M and K).</p><pre><code class="language-julia hljs">using OpticalFibers
using OpticalFibers.ModeSolvers
using Gridap
using GridapGmsh
using Plots

kt,weight=compute_kt(2,:Hexagon,Irreducible=true,MeshType=:Edge,Pitch=10)
epsilon2D=x-&gt;(1.47-0.02*(hypot(x[1],x[2])&gt;=3))^2
model = GmshDiscreteModel(&quot;../../models/Cell_Hexagon2.msh&quot;)
lambda=0.8:0.025:1.6
mm=Matrix{Vector{Mode}}(undef,length(lambda),length(kt))
Threads.@threads for i in 1:length(kt)
    mm[:,i]=FEM2D_periodic.(lambda,epsilon2D,Ref(model),neigs=30,field=true,kt=kt[i]);
end
neff=zeros(length(lambda),length(kt),30)
P=plot()
a=palette([:red,:green,:blue],length(kt))
plot!(P,lambda,1.45*ones(length(lambda)),color=:black,label=&quot;&quot;)
for i=1:30
    neff[:,:,i]=[real(m[i].neff) for m in mm]
    for k=1:length(kt)
        plot!(P,lambda,neff[:,k,i],color=a[k],label=&quot;&quot;)
    end
end
P.series_list[2].plotattributes[:label]=&quot;Γ&quot;
P.series_list[3].plotattributes[:label]=&quot;M&quot;
P.series_list[4].plotattributes[:label]=&quot;K&quot;
xlabel!(&quot;Wavelength (µm)&quot;)
ylabel!(&quot;Effective index&quot;)
ylims!((1.43,1.47))</code></pre><img src="a9cbfc24.svg" alt="Example block output"/><p>To compute the fundamental mode, it is necessary to compute an approximative value of the effective index based on the band diagram.</p><pre><code class="language-julia hljs">using Interpolations
neff_approx=(max.(neff[5:18,2,7],neff[5:18,1,7])+min.(neff[5:18,2,6],1.45))/2
interp=LinearInterpolation(lambda[5:18],neff_approx)
model_PBG = GmshDiscreteModel(&quot;../../models/PBG.msh&quot;)
Pitch=10
r_hole=3
pos=ring.(1:4)
xc=vcat(first.(pos)...)*Pitch
yc=vcat(last.(pos)...)*Pitch
eps_PBG(x) = (any(@. hypot(x[1]-xc,x[2]-yc)&lt;r_hole)) ? 1.47^2 : 1.45^2
lambda_PBG=0.925:0.005:1.115
mode_PBG=Vector{Vector{Mode}}(undef,length(lambda_PBG))
for i=1:length(lambda_PBG)
    mode_PBG[i]=FEM2D(lambda_PBG[i],eps_PBG,model_PBG,neigs=1,approx_neff=interp(lambda_PBG[i]),field=true,solver=:MUMPS,dPML=4)
end
mode_PBG=vcat(mode_PBG...)
neff_PBG=getproperty.(mode_PBG,:neff)
Aeff_PBG=Aeff.(mode_PBG)
omega=2*pi*OpticalFibers.PhysicalData.c./lambda_PBG*1E6
beta=real(neff_PBG)*2*pi./lambda_PBG*1E6
omega2,beta2=derivative((omega,beta),2)
lambda2=2*pi*OpticalFibers.PhysicalData.c./omega2*1E6
losses_PBG=losses.(mode_PBG)*1E6
p1=plot(lambda_PBG,losses_PBG,yaxis=:log,xlabel=&quot;λ (µm)&quot;,ylabel=&quot;Losses (dB/km)&quot;)
p2=plot(lambda_PBG,Aeff_PBG,xlabel=&quot;λ (µm)&quot;,ylabel=&quot;Aeff (µm²)&quot;)
p3=plot(lambda2,beta2*1E26,xlabel=&quot;λ (µm)&quot;,ylabel=&quot;β₂ (10⁻²⁶ s²/m)&quot;)
plot(p1, p2, p3, layout=(1,3), legend=false)</code></pre><img src="04f85322.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PhysicalData/">« PhysicalData</a><a class="docs-footer-nextpage" href="../ModeSolvers-Solvers/">ModeSolvers-Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 5 February 2025 11:19">Wednesday 5 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
