<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModeSolvers-Solvers · Opticalfibers.jl</title><meta name="title" content="ModeSolvers-Solvers · Opticalfibers.jl"/><meta property="og:title" content="ModeSolvers-Solvers · Opticalfibers.jl"/><meta property="twitter:title" content="ModeSolvers-Solvers · Opticalfibers.jl"/><meta name="description" content="Documentation for Opticalfibers.jl."/><meta property="og:description" content="Documentation for Opticalfibers.jl."/><meta property="twitter:description" content="Documentation for Opticalfibers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Opticalfibers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Unitful_Gridap/">Unitful and Gridap</a></li><li><a class="tocitem" href="../Common/">Common functions</a></li><li><a class="tocitem" href="../PhysicalData/">PhysicalData</a></li><li><a class="tocitem" href="../ModeSolvers-Tutorial/">ModeSolvers-Tutorial</a></li><li><a class="tocitem" href="../ModeSolvers/">ModeSolvers-Modes and Fields</a></li><li class="is-active"><a class="tocitem" href>ModeSolvers-Solvers</a><ul class="internal"><li><a class="tocitem" href="#Quasi-analytical-multi-step-index-fibers-solver"><span>Quasi-analytical multi-step index fibers solver</span></a></li><li><a class="tocitem" href="#Finite-element-mode-solvers"><span>Finite element mode solvers</span></a></li></ul></li><li><a class="tocitem" href="../Bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ModeSolvers-Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModeSolvers-Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OpticalFibers.ModeSolvers-Solvers"><a class="docs-heading-anchor" href="#OpticalFibers.ModeSolvers-Solvers">OpticalFibers.ModeSolvers - Solvers</a><a id="OpticalFibers.ModeSolvers-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#OpticalFibers.ModeSolvers-Solvers" title="Permalink"></a></h1><h2 id="Quasi-analytical-multi-step-index-fibers-solver"><a class="docs-heading-anchor" href="#Quasi-analytical-multi-step-index-fibers-solver">Quasi-analytical multi-step index fibers solver</a><a id="Quasi-analytical-multi-step-index-fibers-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-analytical-multi-step-index-fibers-solver" title="Permalink"></a></h2><p>This solver assumes that the fiber consists of several concentric layers of uniform refractive index. The cladding is assumed to be infinite. In each layer, the analytical solutions are the Bessel functions. The solver uses the interface conditions to predict the effective index and the profile of the modes. This method is described in the book written by J. Bures [<a href="../Bibliography/#Bures2009">10</a>].  </p><p>This solver only returns guided modes: the effective index of the mode is real and cannot be lower than the refractive index of the outer cladding. </p><article><details class="docstring" open="true"><summary id="OpticalFibers.ModeSolvers.multi_step_fiber_modes"><a class="docstring-binding" href="#OpticalFibers.ModeSolvers.multi_step_fiber_modes"><code>OpticalFibers.ModeSolvers.multi_step_fiber_modes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multi_step_fiber_modes(lambda::realLength,nu::Integer,radius::Union{Vector{&lt;:realLength},realLength},index::Vector{&lt;:Real};field::Bool=false,precision::Float64=1E-12,type::Symbol=:Scalar,firstDivision::Integer=0)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFunction1D}</code> if type=:Scalar or a vector of <code>Mode{VectorFieldFunction2D}</code> if type=:Vector.</p><ul><li>lambda: wavelength</li><li>nu: azimuthal number</li><li>radius: outer radius of each layer (the cladding is inifinite and has no radius)</li><li>index: refractive index of each layer (the cladding is included so that length(index) must be equal to length(radius)+1)</li><li>field: boolean that indicates if fields must be saved</li><li>precision: absolute precision required on the effective index </li><li>type: must be :Scalar (default) or :Vector</li><li>firstDivision: in the case of a very multimode fiber, you can increase this number if some modes are missing. If firstDivision=0, the value of firstDivision is approximated by the solver.</li></ul></div></section><section><div><pre><code class="language-julia hljs">multi_step_fiber_modes(lambda::Real,nu::Integer,radius::Union{Vector{&lt;:Real},Real},index::Vector{&lt;:Real};field::Bool=false,precision::Float64=1E-12,type::Symbol=:Scalar,firstDivision::Integer=0)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFunction1D}</code> if type=:Scalar or a vector of <code>Mode{VectorFieldFunction2D}</code> if type=:Vector.</p><ul><li>lambda: wavelength (m)</li><li>nu: azimuthal number</li><li>radius: outer radius of each layer (m, the cladding is inifinite and has no radius)</li><li>index: refractive index of each layer (the cladding is included so that length(index) must be equal to length(radius)+1)</li><li>field: boolean that indicates if fields must be saved</li><li>precision: absolute precision required on the effective index </li><li>type: must be :Scalar (default) or :Vector</li><li>firstDivision: in the case of a very multimode fiber, you can increase this number if some modes are missing. If firstDivision=0, the value of firstDivision is approximated by the solver.</li></ul></div></section></details></article><h2 id="Finite-element-mode-solvers"><a class="docs-heading-anchor" href="#Finite-element-mode-solvers">Finite element mode solvers</a><a id="Finite-element-mode-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-mode-solvers" title="Permalink"></a></h2><p>The FEM solvers are based on <code>Gridap.jl</code> and can compute modes of isotropic (functions <code>FEM1D</code> and <code>FEM2D</code>) and anisotropic fibers (function <code>FEM2D_anisotropic</code>). If a PML is not used, the functions <code>FEM1D</code> and <code>FEM2D</code> compute guided modes only. To compute the leaky modes, the user must add a PML by setting the value of dPML in these functions.  If the fiber is twisted, the computed modes must be vector modes. The function <code>FEM2D_periodic</code> can compute the modes of periodic fibers (for example photonic crystal fibers) but the mesh must also be periodic.</p><p>The computation of the effective index amounts to an eigenvalue problem which is solved by using the package <code>ArnoldiMethod.jl</code> combined with a LU decomposition performed with <code>LinearAlgebra.jl</code> or <code>MUMPS.jl</code>. Note that in the case of anisotropic fibers (when using a PML for example), the dimension of the matrix is twice as large as in the case of isotropic fibers and <code>MUMPS.jl</code> is generally faster that <code>LinearAlgebra.jl</code>. On the other hand, this is not possible to use <code>MUMPS.jl</code> with <code>Threads.jl</code> because <code>MUMPS.jl</code> uses its own threads system.</p><article><details class="docstring" open="true"><summary id="OpticalFibers.ModeSolvers.FEM1D"><a class="docstring-binding" href="#OpticalFibers.ModeSolvers.FEM1D"><code>OpticalFibers.ModeSolvers.FEM1D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FEM1D(lambda::realLength,nu::Int64,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,dPML::realLength=0u&quot;m&quot;,alphaPML::Real=10)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFEM1D}</code>.   The fiber is assumed to be isotropic with a cylindrical symmetry and is described with its relative permittivity.</p><ul><li>lambda: wavelength</li><li>nu: azimuthal number</li><li>n_fonc: function of r that describes the refractive index profile n(r)</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> with a unit</li><li>neigs: number of modes to compute</li><li>approx_neff: effective index around which the modes will be computed</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>dPML: Thickness of the PML</li><li>alphaPML: attenuation coefficient of the PML</li></ul></div></section><section><div><pre><code class="language-julia hljs">FEM1D(lambda::Real,nu::Int64,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFEM1D}</code>.   The fiber is assumed to be isotropic with a cylindrical symmetry and is described with its relative permittivity.</p><ul><li>lambda: wavelength (m)</li><li>nu: azimuthal number</li><li>n_fonc: function of r that describes the refractive index profile n(r)</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> (m)</li><li>neigs: number of modes to compute</li><li>approx_neff: effective index around which the modes will be computed</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>dPML: Thickness of the PML (m)</li><li>alphaPML: attenuation coefficient of the PML</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OpticalFibers.ModeSolvers.FEM2D"><a class="docstring-binding" href="#OpticalFibers.ModeSolvers.FEM2D"><code>OpticalFibers.ModeSolvers.FEM2D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FEM2D(lambda::realLength,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,dPML::realLength=0u&quot;m&quot;,alphaPML::Real=10,boundary_tag::String=&quot;&quot;,type::Symbol=:Scalar,twistPitch::realLength=Inf*u&quot;m&quot;)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFEM2D}</code> if type=:Scalar or a vector of <code>Mode{VectorFieldFEM2D}</code> if type=:Vector.   The fiber is assumed to be isotropic and is described with its relative permittivity.</p><ul><li>lambda: wavelength</li><li>n_fonc: function of the tuple (x,y) that describes the refractive index profile n(x)</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> with an unit</li><li>neigs: number of modes to compute</li><li>approx_neff: effective index around which the modes will be computed</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>dPML: Thickness of the PML</li><li>alphaPML: attenuation coefficient of the PML</li><li>boundary_tag: tag of the boundary in model. If &quot;&quot;, then the function automatically detects the boundary.</li><li>type: :Scalar or :Vector</li><li>twistPitch: twist pitch of the fiber. If Inf*u&quot;m&quot;, the fiber is untwisted. Works for vector modes only.</li></ul></div></section><section><div><pre><code class="language-julia hljs">FEM2D(lambda::Real,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10,boundary_tag::String=&quot;&quot;,type::Symbol=:Vector,twistPitch::Real=Inf)</code></pre><p>Returns a vector of <code>Mode{ScalarFieldFEM2D}</code> if type=:Scalar or a vector of <code>Mode{VectorFieldFEM2D}</code> if type=:Vector.   The fiber is assumed to be isotropic and is described with its relative permittivity.</p><ul><li>lambda: wavelength (m)</li><li>n_fonc: function of the tuple (x,y) that describes the refractive index profile n(x)</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> (m)</li><li>neigs: number of modes to compute</li><li>approx_neff: effective index around which the modes will be computed</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>dPML: Thickness of the PML (m)</li><li>alphaPML: attenuation coefficient of the PML</li><li>boundary_tag: tag of the boundary in model. If &quot;&quot;, then the function automatically detects the boundary.</li><li>type: :Scalar or :Vector</li><li>twistPitch: twist pitch of the fiber (m). If Inf*u&quot;m&quot;, the fiber is untwisted. Works for vector modes only.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OpticalFibers.ModeSolvers.FEM2D_anisotropic"><a class="docstring-binding" href="#OpticalFibers.ModeSolvers.FEM2D_anisotropic"><code>OpticalFibers.ModeSolvers.FEM2D_anisotropic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FEM2D_anisotropic(lambda::realLength,epsilon_ini::Function,mu_ini::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,boundary_tag::String=&quot;&quot;)</code></pre><p>Returns a vector of <code>Mode{VectorFieldFEM2D}</code>. The fiber is anisotropic and described with its relative permittivity tensor and its relative permeability tensor. The PML is assumed to be already included in the tensors epsilon and mu.</p><ul><li>lambda: wavelength</li><li>epsilon: <code>tensor3</code> with functions of (x,y) that describes the relative permittivity tensor profile</li><li>mu: <code>tensor3</code> with functions of (x,y) that describes the relative permeability tensor profile</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> with a unit</li><li>approx_neff: effective index around which the modes will be computed</li><li>neigs: number of modes to calculate</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>boundary_tag: tag of the boundary in model.</li></ul></div></section><section><div><pre><code class="language-julia hljs">FEM2D_anisotropic(lambda::Real,epsilon_ini::Function,mu_ini::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=1,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,boundary_tag::String=&quot;&quot;)</code></pre><p>Returns a vector of <code>Mode{VectorFieldFEM2D}</code>. The fiber is anisotropic and described with its relative permittivity tensor and its relative permeability tensor. The PML is assumed to be already included in the tensors epsilon and mu.</p><ul><li>lambda: wavelength (m)</li><li>epsilon: <code>tensor3</code> with functions of (x,y) that describes the relative permittivity tensor profile</li><li>mu: <code>tensor3</code> with functions of (x,y) that describes the relative permeability tensor profile</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> (m)</li><li>approx_neff: effective index around which the modes will be computed</li><li>neigs: number of modes to calculate</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>boundary_tag: tag of the boundary in model.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="OpticalFibers.ModeSolvers.FEM2D_periodic"><a class="docstring-binding" href="#OpticalFibers.ModeSolvers.FEM2D_periodic"><code>OpticalFibers.ModeSolvers.FEM2D_periodic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FEM2D_periodic(lambda::realLength,n_fonc::Function,um::UnitfulModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=3,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,kt::AbstractVector{&lt;:inverseRealLength}=[0.0,0.0]u&quot;m^-1&quot;,type::Symbol=:Scalar)</code></pre><p>Returns a vector of <code>Mode</code>. The fiber is isotropic and described with its relative permittivity. The mesh must be periodic.</p><ul><li>lambda: wavelength</li><li>n_fonc: function of (x,y) that describes the refractive index profile</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code> with a unit</li><li>approx_neff: effective index around which the modes will be computed</li><li>neigs: number of modes to calculate</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>kt: vector of the 2D Brillouin zone</li><li>type: :Scalar or :Vector</li></ul></div></section><section><div><pre><code class="language-julia hljs">FEM2D_periodic(lambda::Real,n_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=3,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,kt::AbstractVector{&lt;:Real}=[0.0,0.0],type::Symbol=:Scalar)</code></pre><p>Returns a vector of <code>Mode</code>. The fiber is isotropic and described with its relative permittivity. The mesh must be periodic.</p><ul><li>lambda: wavelength (m)</li><li>n_fonc: function of (x,y) that describes the relative permittivity profile</li><li>model: DiscreteModel generated with <code>GridapGmsh.jl</code></li><li>approx_neff: effective index around which the modes will be computed</li><li>neigs: number of modes to calculate</li><li>order: order of the FEM</li><li>field: boolean that indicates if fields must be saved</li><li>solver: can be :LU, :MUMPS or :CUDSS</li><li>tol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)</li><li>verbose: boolean that enables some outputs</li><li>kt: vector of the 2D Brillouin zone (m^-1)</li><li>type: :Scalar (default) or :Vector</li></ul></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ModeSolvers/">« ModeSolvers-Modes and Fields</a><a class="docs-footer-nextpage" href="../Bibliography/">Bibliography »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 15:34">Friday 6 February 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
