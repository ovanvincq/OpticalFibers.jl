var documenterSearchIndex = {"docs":
[{"location":"ModeSolvers/#OpticalFibers.ModeSolvers-Modes-and-Fields","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers - Modes and Fields","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"CurrentModule = OpticalFibers.ModeSolvers","category":"page"},{"location":"ModeSolvers/#Fields","page":"ModeSolvers-Modes and Fields","title":"Fields","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"This module defines two types of fields: the scalar field (valid in the case of weakly guiding fibers) and the vector field. If the fiber has a cylindrical symmetry, it is sufficient to describe the variations of a scalar field along a radius (the 2D scalar field can be then obtained by multiplying the 1D field by cos(ell theta) or sin(ell theta) where ell is the azimuthal number).","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Four abstract structures are defined to describe an electromagnetic field:","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Field\nScalarField1D\nScalarField2D\nVectorField2D","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.Field","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.Field","text":"abstract type Field end\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarField1D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarField1D","text":"abstract type ScalarField1D <: Field end\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarField2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarField2D","text":"abstract type ScalarField2D <: Field end\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.VectorField2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.VectorField2D","text":"abstract type VectorField2D <: Field end\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Each kind of field can be described by a function, a matrix (a vector in the 1D case) or a CellField when using a FEM solver.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Note that functions are always function of a tuple (r,) in the case of a 1D field or (x,y) in case of a 2D field. This ensures a direct compatibility with the packages Gridap(FEM method) and HCubature (for integration).","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"ScalarFieldFunction1D\nScalarFieldFunction2D\nVectorFieldFunction2D\nScalarFieldMatrix1D\nScalarFieldMatrix2D\nVectorFieldMatrix2D\nScalarFieldFEM1D\nScalarFieldFEM2D\nVectorFieldFEM2D","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldFunction1D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldFunction1D","text":"mutable struct ScalarFieldFunction1D <: ScalarField1D\n\nnu :: Int - Azimuthal number\nE :: Function\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldFunction2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldFunction2D","text":"mutable struct ScalarFieldFunction2D <: ScalarField2D\n\nE :: Function\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.VectorFieldFunction2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.VectorFieldFunction2D","text":"mutable struct VectorFieldFunction2D <: VectorField2D\n\nEx :: Function\nEy :: Function\nEz :: Function\nHx :: Function\nHy :: Function\nHz :: Function\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldMatrix1D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldMatrix1D","text":"mutable struct ScalarFieldMatrix1D <: ScalarField1D\n\nnu :: Int - Azymuthal number\nr :: AbstractVector{<:Real}\nE :: AbstractVector{<:Number}\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldMatrix2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldMatrix2D","text":"mutable struct ScalarFieldMatrix2D <: ScalarField2D\n\nx :: AbstractVector{<:Real}\ny :: AbstractVector{<:Real}\nE :: AbstractMatrix{<:Number}\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.VectorFieldMatrix2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.VectorFieldMatrix2D","text":"mutable struct VectorFieldMatrix2D <: VectorField2D\n\nx :: AbstractVector{<:Real}\ny :: AbstractVector{<:Real}\nEx :: AbstractMatrix{<:Number}\nEy :: AbstractMatrix{<:Number}\nEz :: AbstractMatrix{<:Number}\nHx :: AbstractMatrix{<:Number}\nHy :: AbstractMatrix{<:Number}\nHz :: AbstractMatrix{<:Number}\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldFEM1D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldFEM1D","text":"mutable struct ScalarFieldFEM1D <: ScalarField1D\n\nnu :: Int - Azymuthal number\ndΩ :: Gridap.CellData.Measure\nE :: Gridap.CellField\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.ScalarFieldFEM2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.ScalarFieldFEM2D","text":"mutable struct ScalarFieldFEM2D <: ScalarField2D\n\ndΩ :: Gridap.CellData.Measure\nE :: Gridap.CellField\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.VectorFieldFEM2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.VectorFieldFEM2D","text":"mutable struct VectorFieldMatrix2D <: VectorField2D\n\ndΩ :: Gridap.CellData.Measure\nEx :: Gridap.CellField\nEy :: Gridap.CellField\nEz :: Gridap.CellField\nHx :: Gridap.CellField\nHy :: Gridap.CellField\nHz :: Gridap.CellField\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The fields can be multiplied by a scalar and conjugated. It is also possible to take the real part or the imaginary part of a field. Two fields of the same type can also be added or subtracted.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A function is implemented to compute the value of a field at a given position (r,) in 1D or (x,y) in 2D:","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"computeField","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.computeField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.computeField","text":"computeField(f::ScalarField1D,r::Union{Real,AbstractArray{<:Real}})\n\n\n\n\n\ncomputeField(f::ScalarField2D,x::Union{Real,AbstractArray{<:Real}},y::Union{Real,AbstractArray{<:Real}})\n\n\n\n\n\ncomputeField(f::VectorField2D,x::Union{Real,AbstractArray{<:Real}},y::Union{Real,AbstractArray{<:Real}},component::Symbol=:Ex)\n\n\n\n\n\ncomputeField(m::Mode{<:ScalarField1D},r::Union{Real,AbstractArray{<:Real}},z::Real=0)\n\n\n\n\n\ncomputeField(m::Mode{<:ScalarField2D},x::Union{Real,AbstractArray{<:Real}},y::Union{Real,AbstractArray{<:Real}},z::Real=0)\n\n\n\n\n\ncomputeField(m::Mode{<:VectorField2D},x::Union{Real,AbstractArray{<:Real}},y::Union{Real,AbstractArray{<:Real}},component::Symbol=:Ex,z::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Modes","page":"ModeSolvers-Modes and Fields","title":"Modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A mode is a structure that contains a name, an effective index, the wavelength and, optionally, a field.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"This package assumes that the field is proportionnal to expleft(ibeta z-omega tright).","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Mode","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.Mode","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.Mode","text":"struct Mode{T<:Union{Field,Nothing}}\n\nName :: String\nneff :: Number\nlambda :: Real\nfield :: Field or Nothing\n\n\n\n\n\n","category":"type"},{"location":"ModeSolvers/#Check-if-the-field/mode-is-valid","page":"ModeSolvers-Modes and Fields","title":"Check if the field/mode is valid","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A function was implemented to check if a field or a mode is valid by checking the number of arguments of the functions, the dimension of the matrices or the triangulaiton of the FEM fields. ","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"isvalidField\nisvalidMode","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.isvalidField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.isvalidField","text":"isvalidField(f::Field)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.isvalidMode","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.isvalidMode","text":"isvalidField(m::Mode)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Modes/Fields-conversion","page":"ModeSolvers-Modes and Fields","title":"Modes/Fields conversion","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"It is possible to convert a 1D function or matrix mode/field to 2d. The argument angle corresponds to the orientation in degrees (0 correspond to cos(ell theta) and -90 to sin(ell theta)). This function is not available for FEM mode/field since it requires the creation of a 2D mesh.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"convertTo2D","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.convertTo2D","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.convertTo2D","text":"convertTo2D(f::ScalarFieldFunction1D,angle::Real=0)\n\n\n\n\n\nconvertTo2D(m::Mode{ScalarFieldFunction1D},angle::Real=0)\n\n\n\n\n\nconvertTo2D(f::ScalarFieldMatrix1D,angle::Real=0)\n\n\n\n\n\nconvertTo2D(m::Mode{ScalarFieldMatrix1D},angle::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"It is also possible to convert a function or FEM field to a matrix mode/field.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"convertToMatrix","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.convertToMatrix","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.convertToMatrix","text":"convertToMatrix(f::ScalarField1D,r::AbstractVector{<:Real})\n\n\n\n\n\nconvertToMatrix(m::Mode{<:ScalarField1D},r::AbstractVector{<:Real})\n\n\n\n\n\nconvertToMatrix(f::ScalarField2D,x::AbstractVector{<:Real},y::AbstractVector{<:Real})\n\n\n\n\n\nconvertToMatrix(m::Mode{<:ScalarField2D},x::AbstractVector{<:Real},y::AbstractVector{<:Real})\n\n\n\n\n\nconvertToMatrix(f::VectorField2D,x::AbstractVector{<:Real},y::AbstractVector{<:Real})\n\n\n\n\n\nconvertToMatrix(m::Mode{<:VectorField2D},x::AbstractVector{<:Real},y::AbstractVector{<:Real})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"A mode that contains a ScalarField2D field can be converted to a mode with a VectorField2D with the approximation veck=beta vece_z and E_z=H_z=0.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"convertToVector","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.convertToVector","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.convertToVector","text":"convertToVector(m::Mode{<:ScalarField2D},angle::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Propagation-of-modes","page":"ModeSolvers-Modes and Fields","title":"Propagation of modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The field due to the propagation of a mode after a propagation distance z can be calculated by using this function:","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"getField","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.getField","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.getField","text":"getField(m::Mode,z::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Losses","page":"ModeSolvers-Modes and Fields","title":"Losses","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The mode losses are computed from the imaginary part of the effective index.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The function returns the losses of a mode in dB/km if the wavelength is in meters. If the wavelength is in microns, you have to multiply the result by 1E6 to obtain the losses in dB/km. ","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"losses(::Mode)","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.losses-Tuple{OpticalFibers.ModeSolvers.Mode}","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.losses","text":"losses(m::Mode)\n\n\n\n\n\n","category":"method"},{"location":"ModeSolvers/#Poynting-vector","page":"ModeSolvers-Modes and Fields","title":"Poynting vector","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"Convenient functions that compute the Poynting vector of 2D modes and fields. All functions return a tuple (Px,Py,Pz) that contains the three components of the Poynting vector in the same type as the field.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"PoyntingVector","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.PoyntingVector","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.PoyntingVector","text":"PoyntingVector(f::VectorField2D)\n\n\n\n\n\nPoyntingVector(m::Mode{<:ScalarField2D})\n\n\n\n\n\nPoyntingVector(m::Mode{<:VectorField2D})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Mode-normalization","page":"ModeSolvers-Modes and Fields","title":"Mode normalization","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The modes given by the mode solvers of this package are not normalized. You can normalize them by using the function normalize!. The vector modes are normalized so as vert iint frac12left(vecEwedgevecH^*right) dS vert=1 and the scalar mode are normalized like vector modes if the optional parameter unitIntegral is false or so as $ \\iint \\vert E \\vert^2 dS=1 $ if unitIntegral is true.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"normalize!","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.normalize!","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.normalize!","text":"normalize!(m::Mode{ScalarFieldFunction1D};unitIntegral::Bool=true,kwargs...)\n\n\n\n\n\nnormalize!(m::Mode{ScalarFieldFunction2D};unitIntegral::Bool=true,kwargs...)\n\n\n\n\n\nnormalize!(m::Mode{VectorFieldFunction2D};kwargs...)\n\n\n\n\n\nnormalize!(m::Mode{ScalarFieldMatrix1D};unitIntegral::Bool=true)\n\n\n\n\n\nnormalize!(m::Mode{ScalarFieldMatrix2D};unitIntegral::Bool=true)\n\n\n\n\n\nnormalize!(m::Mode{VectorFieldMatrix2D})\n\n\n\n\n\nnormalize!(m::Mode{ScalarFieldFEM1D};unitIntegral::Bool=true)\n\n\n\n\n\nnormalize!(m::Mode{ScalarFieldFEM2D};unitIntegral::Bool=true)\n\n\n\n\n\nnormalize!(m::Mode{VectorFieldFEM2D})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Overlap-integral","page":"ModeSolvers-Modes and Fields","title":"Overlap integral","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The overlap integral between two fields or modes f_1 and f_2 is langle f_1 vert f_2 rangle = iint E_1 E_2^* dS for scalar fields/modes and langle f_1 vert f_2 rangle = iint frac12left(vecE_1 wedge vecH_2^*right)_z dS for vector fields/modes.  ","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"overlap","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.overlap","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.overlap","text":"overlap(m1::ScalarFieldFunction1D,m2::ScalarFieldFunction1D;kwargs...)\n\n\n\n\n\noverlap(f1::Union{ScalarField,ScalarMode},f2::Union{ScalarField,ScalarMode})\n\n\n\n\n\noverlap(f1::Union{VectorField,VectorMode},f2::Union{VectorField,VectorMode})\n\n\n\n\n\noverlap(m1::ScalarMode1D,m2::ScalarMode1D)\n\n\n\n\n\noverlap(m1::ScalarModeFEM1D,m2::ScalarModeFEM1D)\n\n\n\n\n\noverlap(m1::Union{ScalarFieldFEM,ScalarModeFEM},m2::Union{ScalarFieldFEM,ScalarModeFEM})\n\n\n\n\n\noverlap(m1::Union{VectorFieldFEM,VectorModeFEM},m2::Union{VectorFieldFEM,VectorModeFEM})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Effective-area","page":"ModeSolvers-Modes and Fields","title":"Effective area","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The effective area is defined by:","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"for scalar modes: fracleft( iint vert E vert^2 dS right)^2iint vert E vert^4 dS\nfor vector modes, there are two different values [10] : fracmu_0varepsilon_0fracleft(Releft(iint(vecEwedgevecH^*)_z dSright)right)^2iint n_0^2 vert vecEvecE^* vert^2 dS and fracmu_0varepsilon_0fracleft(Releft(iint(vecEwedgevecH^*)_z dSright)right)^2iint n_0^2 left(vecEvecEright)left(vecE^*vecE^*right) dS where n_0 is the refractive index involved in the relation between the nonlinear index n_2 and the third order susceptibility chi^(3). If n0=0, the function assumes that n0≃neff (correct for weakly-guiding fibers).","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    Aeff","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.Aeff","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.Aeff","text":"Aeff(m::Mode{ScalarFieldFunction1D};kwargs...)\n\n\n\n\n\nAeff(m::Mode{ScalarFieldFunction2D};kwargs...)\n\n\n\n\n\nAeff(m::Mode{VectorFieldFunction2D},n0::Union{Real,Function}=0;kwargs...)\n\n\n\n\n\nAeff(m::Mode{ScalarFieldMatrix1D})\n\n\n\n\n\nAeff(m::Mode{ScalarFieldMatrix2D})\n\n\n\n\n\nAeff(m::Mode{VectorFieldMatrix2D},n0::Union{Real,Function}=0)\n\n\n\n\n\nAeff(m::Mode{ScalarFieldFEM1D})\n\n\n\n\n\nAeff(m::Mode{ScalarFieldFEM2D})\n\n\n\n\n\nAeff(m::Mode{VectorFieldFEM2D},n0::Union{Real,Function}=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Non-linear-coefficient","page":"ModeSolvers-Modes and Fields","title":"Non-linear coefficient","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"If all the lengths are in microns and n_2 is in SI (m²/W), you have to multiply the result by 10^18 to obtain the result in W^-1.m^-1. In this function, n2 is the nonlinear index and n0 is the refractive index involved in the relation between n_2 and the third order susceptibility chi^(3). They must be constants or functions of the tuple (r,) in the 1D case or (x,y) in the 2D case. If n0=0, the function assumes that n0≃neff (correct for weakly-guiding fibers). In the case of modes describes by functions, it is possible to specify the relative and the absolute tolerances for the integral calculations.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    nonLinearCoefficient","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.nonLinearCoefficient","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.nonLinearCoefficient","text":"nonLinearCoefficient(m::Mode{ScalarFieldFunction1D},n2::Union{Real,Function};kwargs...)\n\n\n\n\n\nnonLinearCoefficient(m::Mode{ScalarFieldFunction2D},n2::Union{Real,Function};kwargs...)\n\n\n\n\n\nnonLinearCoefficient(m::Mode{VectorFieldFunction2D},n2::Union{Real,Function},n0::Union{Real,Function}=0;kwargs...)\n\n\n\n\n\nnonLinearCoefficient(m::Mode{ScalarFieldMatrix1D},n2::Union{Real,Function})\n\n\n\n\n\nnonLinearCoefficient(m::Mode{ScalarFieldMatrix2D},n2::Union{Real,Function})\n\n\n\n\n\nnonLinearCoefficient(m::Mode{VectorFieldMatrix2D},n2::Union{Real,Function},n0::Union{Real,Function}=0)\n\n\n\n\n\nnonLinearCoefficient(m::Mode{ScalarFieldFEM1D},n2::Union{Real,Function})\n\n\n\n\n\nnonLinearCoefficient(m::Mode{ScalarFieldFEM2D},n2::Union{Real,Function})\n\n\n\n\n\nnonLinearCoefficient(m::Mode{VectorFieldFEM2D},n2::Union{Real,Function},n0::Union{Real,Function}=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Mode-Field-Diameter-(MFD)","page":"ModeSolvers-Modes and Fields","title":"Mode Field Diameter (MFD)","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The computation MFD is only valid for Gaussian-like beam (maximum at the center of the fiber and electric field with a constant sign). The MFD is calculated by finding the positions where vert E vert=fracmaxleft(vert Evert right)exp(1) for scalar modes and P_z=fracmaxleft(P_zright)exp(2) for vector modes. The optional parameters theta is the angle (in degrees) between the direction along which the MFD is computed and the x-axis. If the field is not quasi-Gaussian (in the case of a higher order mode for example), the value given by this function has no physical meaning.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    MFD","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.MFD","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.MFD","text":"MFD(m::ScalarFieldFunction1D)\n\n\n\n\n\nMFD(m::ScalarFieldFunction2D,theta::Real=0)\n\n\n\n\n\nMFD(m::VectorFieldFunction2D,theta::Real=0)\n\n\n\n\n\nMFD(m::ScalarFieldMatrix1D)\n\n\n\n\n\nMFD(m::ScalarFieldMatrix2D,theta::Real=0)\n\n\n\n\n\nMFD(m::VectorFieldMatrix2D,theta::Real=0)\n\n\n\n\n\nMFD(m::ScalarFieldFEM1D)\n\n\n\n\n\nMFD(m::ScalarFieldFEM2D,theta::Real=0)\n\n\n\n\n\nMFD(m::VectorFieldFEM2D,theta::Real=0)\n\n\n\n\n\nMFD(m::Mode{<:ScalarField1D})\n\n\n\n\n\nMFD(m::Union{Mode{<:ScalarField2D},Mode{<:VectorField2D}},theta::Real=0)\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/#Functions-specific-to-FEM-fields/modes","page":"ModeSolvers-Modes and Fields","title":"Functions specific to FEM fields/modes","text":"","category":"section"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The function writevtk of the package Gridap is overloaded to save a FEM field or mode to a file that can be opened with ParaView.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    writevtk","category":"page"},{"location":"ModeSolvers/#Gridap.Visualization.writevtk","page":"ModeSolvers-Modes and Fields","title":"Gridap.Visualization.writevtk","text":"Gridap.:writevtk(name::String,f::Union{ScalarFieldFEM2D,ScalarFieldFEM1D})\n\n\n\n\n\nGridap.:writevtk(name::String,f::VectorFieldFEM2D)\n\n\n\n\n\nGridap.:writevtk(name::String,m::Union{Mode{ScalarFieldFEM2D},Mode{ScalarFieldFEM1D},Mode{VectorFieldFEM2D}})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"The function get_triangulation of the package Gridap is overloaded to get the triangulation of a FEM field (which is needed to plot a field with GridapMakie for example).","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    get_triangulation","category":"page"},{"location":"ModeSolvers/#Gridap.Geometry.get_triangulation","page":"ModeSolvers-Modes and Fields","title":"Gridap.Geometry.get_triangulation","text":"Gridap.:get_triangulation(m::Union{Mode{ScalarFieldFEM2D},Mode{ScalarFieldFEM1D},Mode{VectorFieldFEM2D}})\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"To compute the value of a CellField at a position (x,y), the function getValue is implemented to overcome the bug encountered in Gridap.jl when using an unregular triangular mesh (see issue 981). This function returns the value of the CellField at the positions given by the matrix of Gridap.Point p.","category":"page"},{"location":"ModeSolvers/","page":"ModeSolvers-Modes and Fields","title":"ModeSolvers-Modes and Fields","text":"    getValue","category":"page"},{"location":"ModeSolvers/#OpticalFibers.ModeSolvers.getValue","page":"ModeSolvers-Modes and Fields","title":"OpticalFibers.ModeSolvers.getValue","text":"getValue(f::Gridap.CellField,p::AbstractArray{<:Point})\n\n\n\n\n\ngetValue(f::Gridap.CellField,p::Point)\n\n\n\n\n\n","category":"function"},{"location":"PhysicalData/#OpticalFibers","page":"PhysicalData","title":"OpticalFibers","text":"","category":"section"},{"location":"PhysicalData/","page":"PhysicalData","title":"PhysicalData","text":"CurrentModule = OpticalFibers.PhysicalData","category":"page"},{"location":"PhysicalData/#Constants","page":"PhysicalData","title":"Constants","text":"","category":"section"},{"location":"PhysicalData/","page":"PhysicalData","title":"PhysicalData","text":"Modules = [PhysicalData,]\nOrder = [:constant]","category":"page"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Z0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Z0","text":"Z0=sqrt(mu0/eps0)\n\nVaccum impedance (Ω)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.c","page":"PhysicalData","title":"OpticalFibers.PhysicalData.c","text":"c=299792458.0\n\nVelocity of light in vacuum (m/s)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.eps0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.eps0","text":"eps0=1/(mu0*c^2)\n\nVaccum permittivity (F/m)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.h","page":"PhysicalData","title":"OpticalFibers.PhysicalData.h","text":"h=6.62607015e-34\n\nPlanck constant (J.s)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.mu0","page":"PhysicalData","title":"OpticalFibers.PhysicalData.mu0","text":"mu0=1.25663706212e-6\n\nVaccum permeability (H/m)\n\n\n\n\n\n","category":"constant"},{"location":"PhysicalData/#Functions","page":"PhysicalData","title":"Functions","text":"","category":"section"},{"location":"PhysicalData/","page":"PhysicalData","title":"PhysicalData","text":"Modules = [PhysicalData,]\nOrder = [:function]","category":"page"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Sa_Ytterbium-Tuple{Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Sa_Ytterbium","text":"Sa_Ytterbium(lambda::Real)\n\nReturns the absorption cross section (in m²) of ytterbium [2]  \n\nlambda: Wavelength (m)\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.Se_Ytterbium-Tuple{Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.Se_Ytterbium","text":"Se_Ytterbium(lambda::Real)\n\nReturns the emission cross section (in m²) of ytterbium [2]  \n\nlambda: Wavelength (m)\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_F_Doped_Silica-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_F_Doped_Silica","text":"n_F_Doped_Silica(lambda::Real,xF::Real)\n\nReturns the refractive index of Fluorine-doped Silica [3]  \n\nlambda: Wavelength (m) - Domain of validity: 600 nm ≤ lambda ≤ 1800 nm\nxF: Fluorine Fraction (0 ≤ x Ge ≤ 1) - Domain of validity: xF ≤ 0.02\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Ge_Doped_Silica-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Ge_Doped_Silica","text":"n_Ge_Doped_Silica(lambda::Real,xGe::Real;author::Symbol=:Fleming)\n\nIf author==:Fleming, returns the refractive index of Germanium-doped Silica [4]  \n\nlambda: Wavelength (m) - Domain of validity: 360 nm ≤ lambda ≤ 4300 nm\nxGe: Germanium Fraction (0 ≤ xGe ≤ 1)  \n\nIf author==:Sunak, returns the refractive index of Germanium-doped Silica [3]  \n\nlambda: Wavelength (m) - Domain of validity: 600 nm ≤ lambda ≤ 1800 nm\nxGe: Germanium Fraction (0 ≤ x Ge ≤ 1) - Domain of validity: xGe ≤ 0.2\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Germanium-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Germanium","text":"n_Germanium(lambda::Real,T::Real)\n\nReturns the refractive index of Germanium [5]  \n\nlambda: Wavelength (m) - Domain of validity: 1900 nm ≤ lambda ≤ 5500 nm\nT: Temperature (K) - Domain of validity: 20 K ≤ T ≤ 300 K\n\n\n\n\n\n","category":"method"},{"location":"PhysicalData/#OpticalFibers.PhysicalData.n_Silicon-Tuple{Real, Real}","page":"PhysicalData","title":"OpticalFibers.PhysicalData.n_Silicon","text":"n_Silicon(lambda::Real,T::Real)\n\nReturns the refractive index of Silicon [5]  \n\nlambda: Wavelength (m) - Domain of validity: 1100 nm ≤ lambda ≤ 5600 nm\nT: Temperature (K) - Domain of validity: 20 K ≤ T ≤ 300 K\n\n\n\n\n\n","category":"method"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers-Solvers","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers - Solvers","text":"","category":"section"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"CurrentModule = OpticalFibers.ModeSolvers","category":"page"},{"location":"ModeSolvers-Solvers/#Quasi-analytical-multi-step-index-fibers-solver","page":"ModeSolvers-Solvers","title":"Quasi-analytical multi-step index fibers solver","text":"","category":"section"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"This solver assumes that the fiber consists of several concentric layers of uniform refractive index. The cladding is assumed to be infinite. In each layer, the analytical solutions are the Bessel functions. The solver uses the interface conditions to predict the effective index and the profile of the modes. This method is described in the book written by J. Bures [9].  ","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"This solver only returns guided modes: the effective index of the mode is real and cannot be lower than the refractive index of the outer cladding. ","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"    multi_step_fiber_modes","category":"page"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.multi_step_fiber_modes","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.multi_step_fiber_modes","text":"multi_step_fiber_modes(lambda::Real,nu::Integer,radius::Union{Vector{<:Real},Real},index::Vector{<:Real};field::Bool=false,precision::Float64=1E-12,type::Symbol=:Scalar,firstDivision::Integer=0)\n\nReturns a vector of Mode{ScalarFieldFunction1D} if type=:Scalar or a vector of Mode{VectorFieldFunction2D} if type=:Vector.\n\nlambda: wavelength\nnu: azimuthal number\nradius: outer radius of each layer (the cladding is inifinite and has no radius)\nindex: refractive index of each layer (the cladding is included so that length(index) must be equal to length(radius)+1)\nfield: boolean that indicates if fields must be saved\nprecision: absolute precision required on the effective index \ntype: must be :Scalar or :Vector\nfirstDivision: in the case of a very multimode fiber, you can increase this number if some modes are missing. If firstDivision=0, the value of firstDivision is approximated by the solver.\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#Finite-element-mode-solvers","page":"ModeSolvers-Solvers","title":"Finite element mode solvers","text":"","category":"section"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"The FEM solvers are based on Gridap.jl and can compute modes of isotropic (functions FEM1D and FEM2D) and anisotropic fibers (function FEM2D_general). If a PML is not used, the functions FEM1D and FEM2D compute guided modes only. To compute the leaky modes, the user must add a PML by setting the value of dPML in these functions. ","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"The computation of the effective index amounts to an eigenvalue problem which is solved by using the package ArnoldiMethod.jl combined with LinearAlgebra.jl (LU decomposition) or MUMPS.jl. Note that in the case of anisotropic fibers, the dimension of the matrix is twice as large as in the case of isotropic fibers.","category":"page"},{"location":"ModeSolvers-Solvers/","page":"ModeSolvers-Solvers","title":"ModeSolvers-Solvers","text":"    FEM1D\n    FEM2D\n    FEM2D_anisotropic\n    FEM2D_periodic","category":"page"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM1D","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM1D","text":"FEM1D(lambda::Real,nu::Int64,eps_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10)\n\nReturns a vector of Mode{ScalarFieldFEM1D}.   The fiber is assumed to be isotropic with a cylindrical symmetry and is described with its relative permittivity.\n\nlambda: wavelength\nnu: azimuthal number\neps_fonc: function of r that describes the relative permittivity profile i.e. eps(r)=n(r)^2\nmodel: DiscreteModel generated with GridapGmsh.jl\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU or :MUMPS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML\nalphaPML: attenuation coefficient of the PML\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D","text":"FEM2D(lambda::Real,eps_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,dPML::Real=0,alphaPML::Real=10,boundary_tag::String=\"\",type::Symbol=:Scalar)\n\nReturns a vector of Mode{ScalarFieldFEM2D} if type=:Scalar or a vector of Mode{VectorFieldFEM2D} if type=:Vector.   The fiber is assumed to be isotropic and is described with its relative permittivity.\n\nlambda: wavelength\neps_fonc: function of the tuple (x,y) that describes the relative permittivity profile i.e. eps(x)=n(x)^2\nmodel: DiscreteModel generated with GridapGmsh.jl\nneigs: number of modes to compute\napprox_neff: effective index around which the modes will be computed\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU or :MUMPS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\ndPML: Thickness of the PML\nalphaPML: attenuation coefficient of the PML\nboundary_tag: tag of the boundary in model. If \"\", then the function automatically detects the boundary.\ntype: :Scalar or :Vector\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D_anisotropic","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D_anisotropic","text":"FEM2D_anisotropic(lambda::Real,epsilon::tensor3,mu::tensor3,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=1,field::Bool=false,solver::Symbol=:LU,tol::Float64=0.0,verbose::Bool=false,boundary_tag::String=\"\")\n\nReturns a vector of Mode{VectorFieldFEM2D}. The fiber is anisotropic and described with its relative permittivity tensor and its relative permeability tensor. The PML is assumed to be already included in the tensors epsilon and mu.\n\nlambda: wavelength\nepsilon: tensor3 with functions of (x,y) that describes the relative permittivity tensor profile\nmu: tensor3 with functions of (x,y) that describes the relative permeability tensor profile\nmodel: DiscreteModel generated with GridapGmsh.jl\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU or :MUMPS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nboundary_tag: tag of the boundary in model.\n\n\n\n\n\n","category":"function"},{"location":"ModeSolvers-Solvers/#OpticalFibers.ModeSolvers.FEM2D_periodic","page":"ModeSolvers-Solvers","title":"OpticalFibers.ModeSolvers.FEM2D_periodic","text":"FEM2D_periodic(lambda::Real,eps_fonc::Function,model::DiscreteModel;approx_neff::Real=0,neigs::Int64=1,order::Int64=2,field::Bool=false,solver::Symbol=:LU,tol::Real=0.0,verbose::Bool=false,kt::AbstractVector{<:Real}=[0.0,0.0],type::Symbol=:Scalar)\n\nReturns a vector of Mode. The fiber is isotropic and described with its relative permittivity. The mesh must be periodic.\n\nlambda: wavelength\nepsilon: function of (x,y) that describes the relative permittivity profile\nmodel: DiscreteModel generated with GridapGmsh.jl\napprox_neff: effective index around which the modes will be computed\nneigs: number of modes to calculate\norder: order of the FEM\nfield: boolean that indicates if fields must be saved\nsolver: can be :LU or :MUMPS\ntol: tolerance for the eigenvalue solver (see documention of ArnoldiMethod.jl)\nverbose: boolean that enables some outputs\nkt: vector of the 2D Brillouin zone\ntype: :Scalar or :Vector\n\n\n\n\n\n","category":"function"},{"location":"Bibliography/#References","page":"Bibliography","title":"References","text":"","category":"section"},{"location":"Bibliography/","page":"Bibliography","title":"Bibliography","text":"K. Saitoh and M. Koshiba. Empirical relations for simple design of photonic crystal fibers. Opt. Express 13, 267–274 (2005).\n\n\n\nJ. R. Marciante and J. D. Zuegel. High-gain, polarization-preserving, Yb-doped fiber amplifier for low-duty-cycle pulse amplification. Appl. Opt. 45, 6798–6804 (2006).\n\n\n\nH. Sunak and S. Bastien. Refractive index and material dispersion interpolation of doped silica in the 0.6-1.8 µm wavelength region. IEEE Photonics Technology Letters 1, 142–145 (1989).\n\n\n\nJ. W. Fleming. Dispersion in GeO2–SiO2 glasses. Appl. Opt. 23, 4486–4493 (1984).\n\n\n\nB. J. Frey, D. B. Leviton and T. J. Madison. Temperature-dependent refractive index of silicon and germanium. In: Optomechanical Technologies for Astronomy, Vol. 6273, edited by E. Atad-Ettedgui, J. Antebi and D. Lemke (International Society for Optics and Photonics, SPIE, 2006); p. 62732J.\n\n\n\nA. .. Snyder and J. Love. Optical Waveguide Theory. 1 Edition (Springer, 1983).\n\n\n\nA. Nicolet, F. Zolla, Y. O. Agha and S. Guenneau. Leaky modes in twisted microstructured optical fibers. Waves in Random and Complex Media 17, 559–570 (2007).\n\n\n\nM. Napiorkowski and W. Urbanczyk. Rigorous simulations of a helical core fiber by the use of transformation optics formalism. Opt. Express 22, 23108–23120 (2014).\n\n\n\nJ. Bures. Optique guidée. Fibres optiques et composants passifs tout-fibre (Presses internationales Polytechnique, 2009).\n\n\n\nJ. Lægsgaard. Modeling of nonlinear propagation in fiber tapers. J. Opt. Soc. Am. B 29, 3183–3191 (2012).\n\n\n\n","category":"page"},{"location":"ModeSolvers-Tutorial/#OpticalFibers.ModeSolvers-Tutorial","page":"ModeSolvers-Tutorial","title":"OpticalFibers.ModeSolvers - Tutorial","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"CurrentModule = OpticalFibers.ModeSolvers","category":"page"},{"location":"ModeSolvers-Tutorial/#Bimodal-Step-index-Fiber","page":"ModeSolvers-Tutorial","title":"Bimodal Step-index Fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"This section explains how to modelize a step-index fiber with a core radius a=2 µm. The refractive index of the core is n_textcore=147 and that of the cladding is n_textcladding=145. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"This fiber is bimodal at lambda=1 µm since the normalized frequency is V=frac2pi alambdasqrtn_textcore^2-n_textcladding^2=304. ","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-Modes","page":"ModeSolvers-Tutorial","title":"Scalar Modes","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the two scalar modes, we can use the fuction multi_step_fiber_modes that returns a vector of modes. The arguments are the wavelength, the azimuthal number, the radius of the core and a vector describing the refractive index. The optional argument field indicates that we want to return modes that contain a field.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"#using Pkg; nothing # hide\n#Pkg.activate(\"../..\"); nothing # hide\nusing OpticalFibers\nusing OpticalFibers.ModeSolvers\nm0=multi_step_fiber_modes(1,0,2,[1.47,1.45],field=true);\nm01=m0[1]\nm1=multi_step_fiber_modes(1,1,2,[1.47,1.45],field=true);\nm11=m1[1]\nnothing; #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Note that you can also use broadcasting to compute all modes with a single command. The function Ref allows to use the same vector of refractive index for all values of the azimuthal number. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m=multi_step_fiber_modes.(1,[0,1],2,Ref([1.47,1.45]),field=true);\nm01=m[1][1];\nm11=m[2][1];\nnothing; #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The mode profile can be easily plotted by using the function computeField","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots\nr=0:0.01:10;\nplot(r,computeField(m01,r),label=m01.Name)\nplot!(r,computeField(m11,r),label=m11.Name)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to visualize the modes in a 2D plot, we can convert the Mode{ScalarFieldFunction1D} to a Mode{ScalarFieldFunction2D} but we have to indicate the orientation of the mode by using the cos function or the sin function. Then, we normalize the modes and plot one of the two LP_11 modes. Be careful when using Plots.jl: unlike this package, the second index of the matrix corresponds to the x-coordinate (as matlab but the opposite of Makie.jl).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mm01=convertTo2D(m01)\nmm11c=convertTo2D(m11)\nmm11s=convertTo2D(m11,90)\nnormalize!(mm01)\nnormalize!(mm11c)\nnormalize!(mm11s)\nx=-8:0.125:8;\ncontourf(x,x,computeField(mm11c,x,x')',levels=100,linewidth=0)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The beating between the LP_01 and the LP_11 can be observed by plotting the sum of the fields for different values of the distance z. The beating length is frac2pivert Delta beta vert = fraclambdavert Delta n_eff vertsimeq 107 µm","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"L=1/(m01.neff-m11.neff)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can take advantage of the possibility to add fields to create the animation.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"anim=@animate for j=0:214\n    TotalField=getField(mm01,j)+getField(mm11c,j);\n    contourf(x,x,abs2.(computeField(TotalField,x,x'))',levels=100,linewidth=0,title=\"z = $j µm\")\nend;\ngif(anim,\"anim_field.gif\",fps=15)","category":"page"},{"location":"ModeSolvers-Tutorial/#Vector-modes","page":"ModeSolvers-Tutorial","title":"Vector modes","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"It is also possible to compute the vector modes of the fiber: LP_01 mode becomes HE_11 mode and LP_11 mode becomes TE_01, TM_01 and HE_21 modes. To compute these modes, we just have to set the argument type to :Vector (its default value is :Scalar).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv0=multi_step_fiber_modes(1,0,2,[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv1=multi_step_fiber_modes(1,1,2,[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv2=multi_step_fiber_modes(1,2,2,[1.47,1.45],field=true,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then, the Poynting vector of the mode HE_21 can be computed and plotted. Since the field is described by functions, the Poynting vector components are also functions of the tuple (x,y).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Px,Py,Pz=PoyntingVector(mv2[1]);\ncontourf(x,x,Pz.(tuple.(x,x'))',linewidth=0,levels=100,xlims=(-4,4),ylims=(-4,4))\nX,Y=meshgrid(x[1:4:end]);\nquiver!(X,Y,quiver=(computeField(mv2[1],x[1:4:end],x[1:4:end]',:Ex)'/20,computeField(mv2[1],x[1:4:end],x[1:4:end]',:Ey)'/20),color=:cyan,arrow=arrow(:closed))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to check the orthoganality of the modes, we can normalize them and compute the overlap integrals. Note that in the case of functions, there are two optionnal arguments for the function overlap: rtol (relative tolerance) and atol (absolute tolerance). These tolerances are used to compute the integrals with the package HCubature. Here, we know that the integrals are very small in the case of two orthogonal modes so that the relative tolerance on the overlap integral cannot be reached because of Bessel function precision. This is why we have imposed an absolute tolerance of 1E-15.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mv=[mv1;mv0;mv2];\nnormalize!.(mv,atol=1E-5);\noverlap.(mv,transpose(mv),atol=1E-15,rtol=1E-5)","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-modes-with-FEM1D","page":"ModeSolvers-Tutorial","title":"Scalar modes with FEM1D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can find the results above using the FEM method. We will start with the 1D method since the fiber has a cylindrical symmetry. The mesh must begin at r=0 and we have set its end at 15 µm. The number of elements is set to 1500. The FEM computation functions require the relative permittivity i.e. the square of the refractive index. We indicate to the the FEM solver that we want to compute 4 eigenvalues but it returns only one since there is only one mode for ell=0.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Gridap\nmodel = CartesianDiscreteModel((0,15),1500)\nepsilon=x->(1.47-0.02*(x[1]>=2))^2\nm0FEM=FEM1D(1,0,epsilon,model,field=true,neigs=4)\nnormalize!(m0FEM[1])\nnormalize!(m0[1])\nr=0:0.01:10\nplot(r,computeField(m0[1],r),label=\"Step-index solver\")\nplot!(r,-real(computeField(m0FEM[1],r)),label=\"FEM1D solver\",line=:dash)","category":"page"},{"location":"ModeSolvers-Tutorial/#Scalar-modes-with-FEM2D","page":"ModeSolvers-Tutorial","title":"Scalar modes with FEM2D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can also use the FEM2D method. For this, we use a mesh created with GMSH and a function of the tuple (xy) that describes the permittivity. We ask the solver to find 4 modes but it returns only 3 because the fiber can only guides the modes LP01, LP11a and LP11b (a and b refer to the orientation of the mode).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapGmsh\nmodel = GmshDiscreteModel(\"../../models/example1.msh\");\nepsilon2D=x->(1.47-0.02*(hypot(x[1],x[2])>=2))^2\nmFEM2D=FEM2D(1,epsilon2D,model,field=true,neigs=4)\nnormalize!.(mFEM2D)\np1=contourf(x,x,real(computeField(mFEM2D[1],x,x'))',levels=50,linewidth=0,aspect_ratio=:equal);\np2=contourf(x,x,real(computeField(mFEM2D[2],x,x'))',levels=50,linewidth=0,aspect_ratio=:equal);\np3=contourf(x,x,real(computeField(mFEM2D[3],x,x'))',levels=50,linewidth=0,aspect_ratio=:equal);\nplot(p1, p2, p3, layout=(1,3), legend=false,size=(900,300))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"abs2.(overlap.(mFEM2D,[mm01 mm11c mm11s]))","category":"page"},{"location":"ModeSolvers-Tutorial/#Vector-modes-with-FEM2D","page":"ModeSolvers-Tutorial","title":"Vector modes with FEM2D","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the vector, we just have to set type to :Vector. We ask the solver to find 8 modes but it returns only 6 because the fiber can only guides 2 modes HE_11, 1 mode becomes TE_01, 1 mode TM_01 and 2 modes HE_21. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"mvFEM2D=FEM2D(1,epsilon2D,model,field=true,neigs=8,type=:Vector)\nnormalize!.(mvFEM2D)\nabs2.(overlap.(mvFEM2D,transpose(mv)))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In addition to the computation of the overlaps, we can verify that the modes given by the quasi-analytical solver and the FEM solver are the same by plotting the fields.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"p1=contourf(x,x,real(computeField(mvFEM2D[4],x,x',:Ex))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ex\");\np2=contourf(x,x,real(computeField(mvFEM2D[4],x,x',:Ey))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ey\");\np3=contourf(x,x,imag(computeField(mvFEM2D[4],x,x',:Ez))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ez\");\np4=contourf(x,x,real(computeField(mvFEM2D[4],x,x',:Hx))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hx\");\np5=contourf(x,x,real(computeField(mvFEM2D[4],x,x',:Hy))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hy\");\np6=contourf(x,x,imag(computeField(mvFEM2D[4],x,x',:Hz))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hz\");\nplot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"p1=contourf(x,x,real(computeField(mv[4],x,x',:Ex))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ex\");\np2=contourf(x,x,real(computeField(mv[4],x,x',:Ey))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ey\");\np3=contourf(x,x,imag(computeField(mv[4],x,x',:Ez))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Ez\");\np4=contourf(x,x,real(computeField(mv[4],x,x',:Hx))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hx\");\np5=contourf(x,x,real(computeField(mv[4],x,x',:Hy))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hy\");\np6=contourf(x,x,imag(computeField(mv[4],x,x',:Hz))',levels=50,linewidth=0,aspect_ratio=:equal,title=\"Hz\");\nplot(p1, p2, p3, p4, p5, p6, layout=(2,3), legend=false,size=(900,600))","category":"page"},{"location":"ModeSolvers-Tutorial/#Gradient-index-fiber-and-dispersion","page":"ModeSolvers-Tutorial","title":"Gradient index fiber and dispersion","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this tutorial, a germanium-doped parabolic gradient index fiber will be studied. The maximum Ge concentration is 20% and the core radius is 3.5 µm. The silica dispersion will be taken into account.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, a vector of Function is created to modelized the dispersive refractive index profile between 1 and 1.5 µm:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers\nusing OpticalFibers.PhysicalData\nusing Plots\nlambda=1:0.01:1.5;\nepsilon=[x->(n_Ge_Doped_Silica(l*1e-6,0)+(n_Ge_Doped_Silica(l*1e-6,0.2)-n_Ge_Doped_Silica(l*1e-6,0))*(x[1]<=3.5)*(1-x[1]^2/3.5^2))^2 for l in lambda];\nr=0:0.1:5;\nplot(r,sqrt.(epsilon[1].(r)),label=\"λ = 1 µm\",xlabel=\"r (µm)\",ylabel=\"Refractive index\");\nplot!(r,sqrt.(epsilon[end].(r)),label=\"λ = 1.5 µm\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The modal content is then computed (note that we must use Ref(model) because length(model) is not defined in Gridap):","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers.ModeSolvers\nusing Gridap\nmodel = CartesianDiscreteModel((0,20),2000)\nm=FEM1D.(lambda,[0,1,2]',epsilon,Ref(model),neigs=2);\n#mode LP01 always exists\nneff01=[real(m[j,1][1].neff) for j in 1:length(lambda)];\nN02=sum((length.(m[:,1])).>=2);\nneff02=[real(m[j,1][2].neff) for j in 1:N02];\nN11=sum((length.(m[:,2])).>=1);\nneff11=[real(m[j,2][1].neff) for j in 1:N11];\nN21=sum((length.(m[:,3])).>=1);\nneff21=[real(m[j,3][1].neff) for j in 1:N21];\nplot(lambda,n_Ge_Doped_Silica.(lambda*1E-6,0),label=\"Silica\",xlabel=\"λ (µm)\",ylabel=\"Effective index\",color=:black);\nplot!(lambda,n_Ge_Doped_Silica.(lambda*1E-6,0.2),label=\"Ge-doped Silica (20%)\",color=:black,line=:dash);\nplot!([lambda,lambda[1:N11],lambda[1:N02],lambda[1:N21]],[neff01,neff11,neff02,neff21],label=[\"LP01\" \"LP11\" \"LP02\" \"LP21\"])","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The second-order dispersion is defined by beta_2=fracpartial^2 betapartial omega^2.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"beta01=neff01*2*pi./lambda*1E6;\nomega=2*pi*OpticalFibers.PhysicalData.c./lambda*1E6;\nomega2,beta2=derivative((omega,beta01),2);\nlambda2=2*pi*OpticalFibers.PhysicalData.c./omega2*1E6;\nplot(lambda2,beta2*1E26,xlabel=\"λ (µm)\",ylabel=\"β₂ (10⁻²⁶ s²/m)\",label=\"LP01\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the effective area and the non-linear coefficient of the fundamental mode, the fields must be calculated:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m=FEM1D.(lambda,0,epsilon,Ref(model),field=true);\nm=[m[i][1] for i in 1:length(lambda)];\nA=Aeff.(m);\ngamma=nonLinearCoefficient.(m,2.53E-20)*1E21;\nplot(lambda,A,label=\"Aeff\",ylabel=\"Effective area (µm²)\",xlabel=\"λ (µm)\",color=:blue,leg=:topright);\nplot!(twinx(),lambda,gamma,label=\"γ\",ylabel=\"Non-linear coefficient ((W.km)⁻¹)\",color=:red,leg=:topleft)","category":"page"},{"location":"ModeSolvers-Tutorial/#Leaky-modes-in-step-index-fiber-with-a-low-index-trench","page":"ModeSolvers-Tutorial","title":"Leaky modes in step index fiber with a low index trench","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/#Circular-core","page":"ModeSolvers-Tutorial","title":"Circular core","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, we study a fiber with the parameters below:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"core with a radius of 4 µm and a refractive index of 1.46\na trench located between 4 µm and 7 µm with a refractive index of 1.41\na cladding with a refractive index of 1.45","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In order to compute the leaky scalar modes at lambda=16 µm, a PML must be added when using a FEM solver. In this example, the PML is located between 12 µm and 15 µm (thickness of 3 µm).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers\nusing OpticalFibers.ModeSolvers\nusing Gridap\nepsilon=x->(1.46-0.05*(x[1]>=4)+0.04*(x[1]>7))^2;\nmodel = CartesianDiscreteModel((0,15),1500)\nm0=FEM1D(1.6,0,epsilon,model,field=true,dPML=3,neigs=10)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The LP_01 mode is the mode 1. Since its effective index is greater than the refractive index of the cladding, this mode is guided and its losses are not significant.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The LP_02 mode is the mode 5, its losses in dB/km can be calculated:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"losses(m0[5])*1e6","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Plots\nr=0:0.01:15\nnormalize!.(m0)\nplot(r,real.(computeField(m0[1],r)),xlabel=\"r (µm)\",ylabel=\"real(E)\",label=\"LP01\")\nplot!(r,-real.(computeField(m0[5],r)),label=\"LP02\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can also compute the effective index of the LP_11 mode:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m1=FEM1D(1.6,1,epsilon,model,field=true,dPML=3,neigs=15);\npos=argmin(losses.(m1)*1E6);\nm1[pos].neff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the leaky vector modes that correspond to the LP_11 mode, we can also add a PML to the FEM2D solver:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Gridap\nusing GridapGmsh\nmodel = GmshDiscreteModel(\"../../models/Step_index_fiber_pml.msh\");\nepsilon2D=x->epsilon(hypot(x[1],x[2]));\nm=FEM2D(1.6,epsilon2D,model,field=true,neigs=4,approx_neff=real(m1[pos].neff),dPML=3,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The field can be plotted using GridapMakie:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapMakie\nusing GLMakie\nfig,ax,plot_obj=GLMakie.plot(get_triangulation(m[1]),real(m[1].field.Ex),axis=(aspect=DataAspect(),),colormap=:jet)\nColorbar(fig[1,2], plot_obj);\nsave(\"FEM_PML_Ex.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Real(Ex) for the first mode)","category":"page"},{"location":"ModeSolvers-Tutorial/#Elliptical-core","page":"ModeSolvers-Tutorial","title":"Elliptical core","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, the fiber is similar to the previous one but the core and the trench are elliptic:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"core with a radius of 4 µm in the x direction and 2 µm in the y direction and a refractive index of 1.46\na trench with a refractive index of 1.41 and located between the core and an ellipse with radii 8 and 4 µm in x and y direction respectively\na cladding with a refractive index of 1.45","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Elliptic Fiber RIP)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"A rectangular PML is added for 12vert x vert  15 µm and 8vert x vert  11 µm to compute the leaky modes.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We can compute the modes in the scalar approximation or the vector modes. The results are similar since the refractive index steps are very low.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"model2 = GmshDiscreteModel(\"../../models/Elliptic_fiber_rectangular_pml.msh\");\nepsilon2=x->(1.46-0.05*(x[1]^2/16+x[2]^2/4>=1)+0.04*(x[1]^2/64+x[2]^2/16>1))^2\nm_scalar=FEM2D(1.6,epsilon2,model2,neigs=2,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"m_vector=FEM2D(1.6,epsilon2,model2,neigs=4,approx_neff=1.44,field=true,solver=:MUMPS,dPML=3,type=:Vector)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The first mode can be saved in a file that can be opened with ParaView:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"writevtk(\"mode1\",m_vector[1]);","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Elliptic Fiber Ex)","category":"page"},{"location":"ModeSolvers-Tutorial/#Bent-fiber","page":"ModeSolvers-Tutorial","title":"Bent fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In this example, we will compute the bending losses of a step-index fiber at a wavelength of 1.55 µm. The core of the fiber has a refractive index of 1.4457 and a radius of 3.5 µm. The refractive index of the cladding is 1.4378.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, we can use the step-index solver to calculate the effective index. Then, the approximate formula given in the Snyder & Love [6] (Formula 23-23, page 481) can be used to compute the attenuation coefficient gamma=2*Im(beta):","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers\nusing OpticalFibers.ModeSolvers\nusing Bessels\nlambda=1.55\nncore=1.4457\nncladding=1.4378\nrho=3.5\ndelta=(ncore^2-ncladding^2)/(2*ncore^2)\nV=2*pi*rho/lambda*sqrt(ncore^2-ncladding^2)\nms0=multi_step_fiber_modes(lambda,0,rho,[ncore,ncladding])\nneff=ms0[1].neff\nU=2*pi*rho/lambda*sqrt(ncore^2-neff^2)\nW=2*pi*rho/lambda*sqrt(neff^2-ncladding^2)\ngamma=x->sqrt(pi)/2/(rho*1E-6)*sqrt(rho*1E-6/x)*U^2/V^2/W^(1.5)/(besselk(1,W)^2)*exp(-4/3*x/(rho*1E-6)*W^3/V^2*delta)\nneff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute losses with FEM in the scalar approximation and neglecting the elasto-optics effect, we must add a PML and multiply the refractive index by (1+xRc) with Rc the bending radius. Note that the cladding must be large enough to contain the turning point (point at which the refractive index equals the effective index): in the case studied here, the cladding outer radius must be at least 25 µm for a bent radius of 10 mm. Then, we construct a model with a PML located between 32 and 35 µm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"We first compute the effective index with the FEM2D function to check that we obtain the same value as with the step-index solver.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapGmsh\nmodel = GmshDiscreteModel(\"../../models/example5.msh\");\nepsilon2D=x->(ncore-(ncore-ncladding)*(hypot(x[1],x[2])>=rho))^2\nmFEM2D=FEM2D(lambda,epsilon2D,model,field=true,neigs=1);\nneff0=mFEM2D[1].neff","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we calculate modes and the attenuation coefficent for Rc between 1 and 10 mm. Note that we use threads to accelerate the computation (this is not possible when using the MUMPS solver because it uses its own threads system and this causes an error).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"RcFEM=1:1:10\ngammaFEM=zeros(length(RcFEM))\nmFEM=Vector{Mode}(undef,length(RcFEM))\nThreads.@threads for i in axes(RcFEM,1)\n    epsilon2D_bent=x->epsilon2D(x)*(1+x[1]/RcFEM[i]*1E-3)^2\n    mFEM2D_bent=FEM2D(lambda,epsilon2D_bent,model,neigs=1,dPML=3,approx_neff=neff0,field=true);\n    mFEM[i]=mFEM2D_bent[1]\n    gammaFEM[i]=2*imag(2*pi*mFEM2D_bent[1].neff/(lambda*1E-6))\nend\nusing Plots\nRc=1:0.01:10\nplot(Rc,gamma.(Rc*1E-3),yaxis=:log,xlabel=\"Rc (mm)\",ylabel=\"γ (m⁻¹)\",label=\"Snyder & Love\")\nplot!(RcFEM,gammaFEM,label=\"FEM2D\")","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The value given by FEM 2D is slighlty different from that predicted by the analytical formula and the difference increases as the bent radius decreases because the mode increasingly distorted.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using GridapMakie\nusing GLMakie\nusing Gridap\nfig=GLMakie.Figure(size=(750,250))\nfig1,ax1=GLMakie.plot(fig[1,1],get_triangulation(mFEM[10]),abs(mFEM[10].field.E),axis=(aspect=DataAspect(),),colormap=:jet);\nfig2,ax2=GLMakie.plot(fig[1,2],get_triangulation(mFEM[3]),abs(mFEM[3].field.E),axis=(aspect=DataAspect(),),colormap=:jet);\nfig3,ax3=GLMakie.plot(fig[1,3],get_triangulation(mFEM[1]),abs(mFEM[1].field.E),axis=(aspect=DataAspect(),),colormap=:jet);\nfig1.title=\"Rc = 10 mm\"\nfig2.title=\"Rc = 3 mm\"\nfig3.title=\"Rc = 1 mm\"\nsave(\"Bent_fiber.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Electric field in the bent fiber)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In the case of vector modes, we can also multiply the refractive index by (1+xRc) but, more rigourously, we have to multiply the permittivity and permeability tensors by left(beginmatrix (1+xRc)  0  0\n0  (1+xRc)  0  0  0  (1+xRc)^-1 endmatrixright). Below, we compute the modes of the fiber with a bent radius of 3 mm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"R=3E3;\neps_anisotrope=tensor3(x->epsilon2D(x)*(1+x[1]/R),x->epsilon2D(x)*(1+x[1]/R),x->epsilon2D(x)/(1+x[1]/R))\nmu_anisotrope=tensor3(x->(1+x[1]/R),x->(1+x[1]/R),x->1.0/(1+x[1]/R))\neps_anisotrope_pml=add_cylindrical_PML(eps_anisotrope,32,3,10)\nmu_anisotrope_pml=add_cylindrical_PML(mu_anisotrope,32,3,10)\nt=FEM2D_anisotropic(lambda,eps_anisotrope_pml,mu_anisotrope_pml,model,approx_neff=neff0,neigs=2,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/#Twisted-fiber","page":"ModeSolvers-Tutorial","title":"Twisted fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The method used to compute the modes of an isotropic fiber is described in a paper written by Nicolet et al. [7]. In the following example, we use the same fiber as in the bent fiber example but instead of being bent, the fiber is twisted with a period of P=2 mm.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"eps_twist=OpticalFibers.add_twist_PML(epsilon2D,2E3,32,3,10)\nmu_twist=add_twist_PML(1,2E3,32,3,10)\nt=FEM2D_anisotropic(lambda,eps_twist,mu_twist,model,approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Modes 2 and 20 are the HE_11 modes. The losses are not significant since the twist has no effect on a circular centered core. However, the effective indices are no more degenerate: as explained by Napiorkowski et al. [8], in the helicoidal coordinates system, the effective index is neffpmfracnu lambdaP with nu the azimuthal number (nu=1 for the HE_11 mode).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"If the core is shifted by 10 µm, losses due to the twist appear:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"epsilon2D_shift=x->(ncore-(ncore-ncladding)*(hypot(x[1]-10,x[2])>=rho))^2\neps_shift_twist=OpticalFibers.add_twist_PML(epsilon2D_shift,2E3,32,3,10)\nmodel_shift = GmshDiscreteModel(\"../../models/example5-decale.msh\");\nt=FEM2D_anisotropic(lambda,eps_shift_twist,mu_twist,model_shift,approx_neff=neff0,neigs=20,field=true,solver=:MUMPS)","category":"page"},{"location":"ModeSolvers-Tutorial/#Photonic-crystal-fiber-(PCF)","page":"ModeSolvers-Tutorial","title":"Photonic crystal fiber (PCF)","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"In a PCF, the modes are not guided modes but leaky modes so that the computation requires a PML. The fiber is constituted of three rings of air hole (n=1) inserted in silica (n=1.45). The pitch is 2 µm, the hole diameter is 1.5 µm and the PML begins at 8 µm from the fiber center and its thickness is 2 µm. ","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: PCF mesh)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"First, the mesh is loaded:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers\nusing OpticalFibers.ModeSolvers\nusing Gridap\nusing GridapGmsh\nusing GridapMakie\nusing GLMakie\nmodel = GmshDiscreteModel(\"../../models/PCF.msh\");","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we define the permittivity function:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Pitch=2\nr_hole=0.75\npos=ring.(1:3)\nxc=vcat(first.(pos)...)*Pitch\nyc=vcat(last.(pos)...)*Pitch\neps_PCF(x) = (any(@. hypot(x[1]-xc,x[2]-yc)<r_hole)) ? 1.0 : 1.45^2","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Then we can compute four modes whose effective indices are close to the approximate value calculated for the fundamental mode at the wavelength of 1.3 µm:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"neff_approx=approx_neff_PCF(1.3,1.5,2);\nm=FEM2D(1.3,eps_PCF,model,neigs=4,approx_neff=neff_approx,field=true,solver=:MUMPS,type=:Vector,dPML=2)","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"The last two modes are fundamental modes. We can compute and plot the z-component of the Poynting vector of the last mode:","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Px,Py,Pz=PoyntingVector(m[end]);\nfig,ax,plot_obj=GLMakie.plot(get_triangulation(Pz),Pz,axis=(aspect=DataAspect(),),colormap=:jet)\nax.xlabel=\"x (µm)\";\nax.ylabel=\"y (µm)\";\nax.title=\"neff = $(m[end].neff)\";\nColorbar(fig[1,2], plot_obj);\nsave(\"FEM2_Pz.png\",fig); nothing #hide","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"(Image: Pz for FM computed with FEM)","category":"page"},{"location":"ModeSolvers-Tutorial/#Photonic-bandgap-fiber","page":"ModeSolvers-Tutorial","title":"Photonic bandgap fiber","text":"","category":"section"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"Before designing a PBG fiber, one has to compute the PBG of the infinite microstructured media that constitutes the cladding. In this example the cladding is a hexagonal lattice of circular rods with a pitch of 6 µm. The rods has a diameter of 3 µm and a refractive index of 1.47 while the cladding background media has a refractive index of 1.45. To compute the PBG, the mesh must be periodic. Since the cell is highly symmetric, the computation of the bands can be restricted to the highest symmetry points of the irreducible Brillouin zone (Γ, M and K).","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using OpticalFibers\nusing OpticalFibers.ModeSolvers\nusing Gridap\nusing GridapGmsh\nusing Plots\n\nkt,weight=compute_kt(2,:Hexagon,Irreducible=true,MeshType=:Edge,Pitch=10)\nepsilon2D=x->(1.47-0.02*(hypot(x[1],x[2])>=3))^2\nmodel = GmshDiscreteModel(\"../../models/Cell_Hexagon2.msh\")\nlambda=0.8:0.025:1.6\nmm=Matrix{Vector{Mode}}(undef,length(lambda),length(kt))\nThreads.@threads for i in 1:length(kt)\n    mm[:,i]=FEM2D_periodic.(lambda,epsilon2D,Ref(model),neigs=30,field=true,kt=kt[i]);\nend\nneff=zeros(length(lambda),length(kt),30)\nP=plot()\na=palette([:red,:green,:blue],length(kt))\nplot!(P,lambda,1.45*ones(length(lambda)),color=:black,label=\"\")\nfor i=1:30\n    neff[:,:,i]=[real(m[i].neff) for m in mm]\n    for k=1:length(kt)\n        plot!(P,lambda,neff[:,k,i],color=a[k],label=\"\")\n    end\nend\nP.series_list[2].plotattributes[:label]=\"Γ\"\nP.series_list[3].plotattributes[:label]=\"M\"\nP.series_list[4].plotattributes[:label]=\"K\"\nxlabel!(\"Wavelength (µm)\")\nylabel!(\"Effective index\")\nylims!((1.43,1.47))","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"To compute the fundamental mode, it is necessary to compute an approximative value of the effective index based on the band diagram.","category":"page"},{"location":"ModeSolvers-Tutorial/","page":"ModeSolvers-Tutorial","title":"ModeSolvers-Tutorial","text":"using Interpolations\nneff_approx=(max.(neff[5:18,2,7],neff[5:18,1,7])+min.(neff[5:18,2,6],1.45))/2\ninterp=LinearInterpolation(lambda[5:18],neff_approx)\nmodel_PBG = GmshDiscreteModel(\"../../models/PBG.msh\")\nPitch=10\nr_hole=3\npos=ring.(1:4)\nxc=vcat(first.(pos)...)*Pitch\nyc=vcat(last.(pos)...)*Pitch\neps_PBG(x) = (any(@. hypot(x[1]-xc,x[2]-yc)<r_hole)) ? 1.47^2 : 1.45^2\nlambda_PBG=0.925:0.005:1.115\nmode_PBG=Vector{Vector{Mode}}(undef,length(lambda_PBG))\nfor i=1:length(lambda_PBG)\n    mode_PBG[i]=FEM2D(lambda_PBG[i],eps_PBG,model_PBG,neigs=1,approx_neff=interp(lambda_PBG[i]),field=true,solver=:MUMPS,dPML=4)\nend\nmode_PBG=vcat(mode_PBG...)\nneff_PBG=getproperty.(mode_PBG,:neff)\nAeff_PBG=Aeff.(mode_PBG)\nomega=2*pi*OpticalFibers.PhysicalData.c./lambda_PBG*1E6\nbeta=real(neff_PBG)*2*pi./lambda_PBG*1E6\nomega2,beta2=derivative((omega,beta),2)\nlambda2=2*pi*OpticalFibers.PhysicalData.c./omega2*1E6\nlosses_PBG=losses.(mode_PBG)*1E6\np1=plot(lambda_PBG,losses_PBG,yaxis=:log,xlabel=\"λ (µm)\",ylabel=\"Losses (dB/km)\")\np2=plot(lambda_PBG,Aeff_PBG,xlabel=\"λ (µm)\",ylabel=\"Aeff (µm²)\")\np3=plot(lambda2,beta2*1E26,xlabel=\"λ (µm)\",ylabel=\"β₂ (10⁻²⁶ s²/m)\")\nplot(p1, p2, p3, layout=(1,3), legend=false)","category":"page"},{"location":"#OpticalFibers.jl","page":"Home","title":"OpticalFibers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers is a package that allows to compute modes of optical fibers. Different methods are implemented to find scalar or vector modes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A semi-analytical solver (based on Bessel functions) for multi-step index fibers.\nFinite element method (using Gridap.jl) for any kind of isotropic or anisotropic fiber. A PML (Perfectly Matched Layer) is implemented to compute losses of leaky modes guided in trench-assisted fibers, PCF (Photonic Crystal Fibers), bent fiber, twisted fiber, etc. The FEM mode solver can also be used to find photonic bandgaps of a PCF cladding.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers requires at least julia 1.9 and can be installed with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OpticalFibers\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Finding-guided-modes-of-a-step-index-fiber-using-the-semi-analytical-mode-solver","page":"Home","title":"Finding guided modes of a step-index fiber using the semi-analytical mode solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computation of the scalar fundamental mode (l=0) of a step index fiber with a core-radius of 2 µm, a refractive index of 1.47 for core and 1.45 for cladding at a wavelength of 1 µm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OpticalFibers\njulia> using OpticalFibers.ModeSolvers\njulia> ms=multi_step_fiber_modes(1,0,2,[1.47,1.45],field=true)\n1-element Vector{Mode}:\n [LP 0,1,1.463179347605715,1,ScalarFieldFunction1D]\njulia> using Plots\njulia> plot(0:0.1:7,abs.(ms[1].field.E.(0:0.1:7)),xlabel=\"r (µm)\",ylabel=\"|E|\",label=\"Fundamental Mode\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Step Index Fiber-FM)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the fundamental vector mode (l=1) of the same fiber:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> mv=multi_step_fiber_modes(1,1,2,[1.47,1.45],type=:Vector)\n1-element Vector{Mode}:\n [HE 1,1,1.4631371608572663,1,Nothing]","category":"page"},{"location":"#Finding-guided-modes-of-a-graded-index-fiber-using-the-FEM-mode-solver","page":"Home","title":"Finding guided modes of a graded-index fiber using the FEM mode solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computation of the scalar modes of a parabolic-index fiber with a core-radius of 4 µm, a refractive index of 1.48 for core center and 1.45 for cladding at a wavelength of 1 µm by using the finite element method with 1000 nodes between r=0 and r=20 µm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OpticalFibers\njulia> using OpticalFibers.ModeSolvers\njulia> using Gridap\njulia> m=FEM1D(1,0,x->(1.45+0.03*(1-x[1]^2/16)*(x[1]<=4))^2,CartesianDiscreteModel((0,20),1000),field=true,neigs=5)\n2-element Vector{Mode{ScalarFieldFEM1D}}:\n [Mode LP n°1,1.471980656971672,1,ScalarFieldFEM1D]\n [Mode LP n°2,1.4561502566053002,1,ScalarFieldFEM1D]\n\njulia> using Plots\njulia> r=0:0.01:10\njulia> plot(r,abs2.(computeField(m[1],r)),label=\"LP₀₁\",xlabel=\"r (µm)\",ylabel=\"|E|²\")\njulia> plot!(r,abs2.(computeField(m[2],r)),label=\"LP₀₂\",xlabel=\"r (µm)\",ylabel=\"|E|²\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Fundamental mode example)","category":"page"},{"location":"#Finding-leaky-modes-of-a-step-index-fiber-with-a-trench-using-the-FEM-mode-solver-with-a-PML","page":"Home","title":"Finding leaky modes of a step-index fiber with a trench using the FEM mode solver with a PML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us consider a step-index fiber with a trench:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core: radius 4 µm and refractive index 1.44\nTrench: thickness 16 µm and refractive index 1.41\nCladding: refractive index 1.43","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the guided modes ell=0 without the cladding:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m=multi_step_fiber_modes(1.6,0,4,[1.44,1.41])\n2-element Vector{Mode}:\n [LP 0,1,1.4345691826486056,1.6,Nothing]\n [LP 0,2,1.4137165538840926,1.6,Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the guided modes ell=0 with the cladding:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> m2=multi_step_fiber_modes(1.6,0,[4,20],[1.44,1.41,1.43])\n1-element Vector{Mode}:\n [LP 0,1,1.4345691826495002,1.6,Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The LP₀₂ becomes leaky when adding the cladding","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute its losses, we have to use the FEM solver with a PML:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> epsilon_trench=x->(1.44-0.03*(x[1]>=4)+0.02*(x[1]>20))^2;\njulia> model_trench = CartesianDiscreteModel((0,50),5000);\njulia> ms1D_trench=FEM1D(1.6,0,epsilon_trench,model_trench,field=true,dPML=5,approx_neff=m[2].neff)\n1-element Vector{Mode{ScalarFieldFEM1D}}:\n [Mode LP n°1,1.4137165449018512 + 1.0825770569063048e-8im,1.6,ScalarFieldFEM1D]\njulia> losses(ms1D_trench[1])*1E6\n369.26063441366387","category":"page"},{"location":"","page":"Home","title":"Home","text":"Losses of the LP₀₂ mode are 369 dB/km.","category":"page"},{"location":"#Finding-bend-losses-using-the-FEM-mode-solver-with-a-PML","page":"Home","title":"Finding bend losses using the FEM mode solver with a PML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us consider the step_index fiber described below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Core: radius 3.5 µm, refractive index 1.4457\nCladding: refractive index 1.4378","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computation of the fundamental mode at lambda=155 µm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ms_straight=multi_step_fiber_modes(1.55,0,3.5,[1.4457,1.4378],field=true)\n1-element Vector{Mode}:\n [LP 0,1,1.4414392004035022,1.55,Nothing]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute the funcamental mode when the fiber is bent, we need to use a 2D mesh generated with GMSH:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GridapGmsh\njulia> model = GmshDiscreteModel(\"./models/example5.msh\")\nInfo    : Reading './models/example5.msh'...\nInfo    : 10 entities\nInfo    : 14768 nodes\nInfo    : 29536 elements\nInfo    : Done reading './models/example5.msh'\nUnstructuredDiscreteModel()","category":"page"},{"location":"","page":"Home","title":"Home","text":"and define the relative permittivity for a straight fiber and for fiber bent with a radius of curvature of 10 mm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> epsilon2D=x->(1.4457-(1.4457-1.4378)*(hypot(x[1],x[2])>=3.5))^2;\njulia> epsilon2D_bent=x->epsilon2D(x)*(1+x[1]/10E3)^2;\njulia> ms2D_bent=FEM2D(1.55,epsilon2D_bent,model,field=true,neigs=1,dPML=3,approx_neff=ms_straight[1].neff)\n1-element Vector{Mode{ScalarFieldFEM2D}}:\n [Mode LP n°1,1.4414582242320717 + 1.5096368959704397e-9im,1.55,ScalarFieldFEM2D]\nlosses(ms2D_bent[1])*1E6","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, the bend losses are 53 dB/km","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticalFibers.jl is maintained by Olivier Vanvincq (University of Lille, PhLAM laboratory).","category":"page"},{"location":"Common/#OpticalFibers-Common-structs-and-functions","page":"Common functions","title":"OpticalFibers - Common structs and functions","text":"","category":"section"},{"location":"Common/","page":"Common functions","title":"Common functions","text":"CurrentModule = OpticalFibers","category":"page"},{"location":"Common/#Convenient-functions","page":"Common functions","title":"Convenient functions","text":"","category":"section"},{"location":"Common/","page":"Common functions","title":"Common functions","text":"    piecewiseIndex\n    meshgrid\n    derivative\n    ring\n    approx_nFSM_PCF\n    approx_neff_PCF\n    add_cylindrical_PML\n    add_rectangular_PML\n    add_twist_PML\n    integrate1D\n    integrate2D\n    compute_kt","category":"page"},{"location":"Common/#OpticalFibers.piecewiseIndex","page":"Common functions","title":"OpticalFibers.piecewiseIndex","text":"piecewiseIndex(pos::Real,r::Union{AbstractVector{<:Real},Real},n::AbstractVector{<:Real})\n\nFunction that returns the refractive index at the position pos in the case of a step-index fiber profile defined by the vectors r and n.\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.meshgrid","page":"Common functions","title":"OpticalFibers.meshgrid","text":"meshgrid(v::AbstractVector)\n\nFunction equivalent to the matlab function\n\n\n\n\n\nmeshgrid(vx::AbstractVector{T}, vy::AbstractVector{T})\n\nFunction equivalent to the matlab function\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.derivative","page":"Common functions","title":"OpticalFibers.derivative","text":"derivative(t::Tuple{Vector{<:Real},Vector{<:Number}})\n\nFunction that returns the derivative dy/dx of the tuple t=(x,y)\n\n\n\n\n\nderivative(t::Tuple{Vector{<:Real},Vector{<:Number}},order::Int64)\n\nFunction that returns the nth order derivative dy/dx of the tuple t=(x,y) \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.ring","page":"Common functions","title":"OpticalFibers.ring","text":"ring(N::Integer)\n\nFunction that returns a tuple of vectors containing the coordinates (x,y) of the holes in the Nth ring of a PCF\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.approx_nFSM_PCF","page":"Common functions","title":"OpticalFibers.approx_nFSM_PCF","text":"approx_nFSM_PCF(lambda::Real,D::Real,pitch::Real)\n\nReturns an approximate value of nFSM for photonic crystal fiber [1]  \n\nlambda: Wavelength\nD: Hole diameter\npitch: Pitch \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.approx_neff_PCF","page":"Common functions","title":"OpticalFibers.approx_neff_PCF","text":"approx_neff_PCF(lambda::Real,D::Real,pitch::Real)\n\nReturns an approximate value of the effective index of the fundamental mode of a photonic crystal fiber [1]  \n\nlambda: Wavelength\nD: Hole diameter\npitch: Pitch \n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_cylindrical_PML","page":"Common functions","title":"OpticalFibers.add_cylindrical_PML","text":"add_cylindrical_PML(epsmu::Union{Number,Function,tensor3},r_pml::Real,d_pml::Real,alpha::Real)\n\nFunction that returns a tensor of permittivity/permeability with a cylindrical PML\n\nepsmu: permittivity/permeability profile of the fiber. The fiber is assumed to be isotropic when epsmu is a Number or a Function\nr_pml: distance between the fiber center and the PML beginning\nd_pml: PML thickness\nalphaPML: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_rectangular_PML","page":"Common functions","title":"OpticalFibers.add_rectangular_PML","text":"add_rectangular_PML(epsmu::Union{Number,Function,tensor3},x_pml::Real,dx_pml::Real,y_pml::Real,dy_pml::Real,alpha::Real)\n\nFunction that returns a tensor of permittivity/permeability with a rectangular PML located at [xpml,xpml+dxpml], [-xpml-dxpml,-xpml], [ypml,ypml+dypml], [-ypml-dypml,-ypml]\n\nepsmu: permittivity/permeability profile of the fiber. The fiber is assumed to be isotropic when epsmu is a Number or a Function\nx_pml: distance between the fiber center and the PML beginning in the x direction\ndx_pml: PML thickness in the x direction\ny_pml: distance between the fiber center and the PML beginning in the y direction\ndy_pml: PML thickness in the y direction\nalphaPML: attenuation factor of the PML\n\n\n\n\n\nadd_rectangular_PML(epsmu::Union{Number,Function,tensor3},xm_pml::Real,xp_pml::Real,dx_pml::Real,ym_pml::Real,yp_pml::Real,dy_pml::Real,alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability with a rectangular PML located at [xppml,xppml+dxpml], [-xmpml-dxpml,-xmpml], [yppml,yppml+dypml], [-ympml-dypml,-ympml]\n\nepsmu: permittivity/permeability profile of the fiber\nxm_pml: minimum position in the x-direction of the beginning of the PML\nxp_pml: maximum position in the x-direction of the beginning of the PML\ndx_pml: PML thickness in the x direction\nym_pml: minimum position in the y-direction of the beginning of the PML\nyp_pml: maximum position in the y-direction of the beginning of the PML\ndy_pml: PML thickness in the y direction\nalphaPML: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.add_twist_PML","page":"Common functions","title":"OpticalFibers.add_twist_PML","text":"add_twist_PML(epsmu::Union{Function,Number},P::Real,r_pml::Real,d_pml::Real,alphaPML::Real)\n\nFunction that returns a tensor of permittivity/permeability of a twisted isotropic fiber with a cylindrical PML\n\nepsmu: function of the tuple (x,y) that describes the permittivity/permeability profile of the fiber\nP: period of the twist\nr_pml: distance between the fiber center and the PML beginning\nd_pml: PML thickness\nalpha: attenuation factor of the PML\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.integrate1D","page":"Common functions","title":"OpticalFibers.integrate1D","text":"integrate1D(f::Function;rtol::Real=1E-5;kwargs...)\n\nIntegrate a 1D function f(r) from 0 to infinity\n\nThe keyword arguments are those of HCubature.jl. In particular,rtol and atol are the relative and the absolute tolerance on the result\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.integrate2D","page":"Common functions","title":"OpticalFibers.integrate2D","text":"integrate2D(f::Function;kwargs...)\n\nIntegrate a 2D function f(r) with r is a the tuple (x,y) for x and y from -infinity to infinity\n\nThe keyword arguments are those of HCubature.jl. In particular,`rtol` and `atol` are the relative and the absolute tolerance on the result\n\n\n\n\n\n","category":"function"},{"location":"Common/#OpticalFibers.compute_kt","page":"Common functions","title":"OpticalFibers.compute_kt","text":"compute_kt(KNumber::Int,CellType::Symbol;Irreducible::Bool=true,Pitch::Real=1,MeshType::Symbol=:Internal)\n\nCompute the vectors of a 2D Brillouin zone\n\nKNumber: Integer related to the number of vectors to compute\nCellType: :Square or :Hexagon\nIrreducible: true-> irreducible Brillouin zone, false->entire Billouin zone\npitch: Pitch \nMeshType: Internal (useful to compute the Density Of States) or :Edge (useful to compute the bandgap edge)\n\n\n\n\n\n","category":"function"},{"location":"Common/#Tensor","page":"Common functions","title":"Tensor","text":"","category":"section"},{"location":"Common/","page":"Common functions","title":"Common functions","text":"    tensorComponent","category":"page"},{"location":"Common/#OpticalFibers.tensorComponent","page":"Common functions","title":"OpticalFibers.tensorComponent","text":"tensorComponent\n\nStructure that describes a the component of the tensor of permittivity or permeability.\n\nf::Union{Function,Number}\n\n\n\n\n\n","category":"type"},{"location":"Common/","page":"Common functions","title":"Common functions","text":"    tensor3\n    inverse\n    det","category":"page"},{"location":"Common/#OpticalFibers.tensor3","page":"Common functions","title":"OpticalFibers.tensor3","text":"tensor\n\nStructure that describes a tensor of permittivity or permeability. Each of the 9 components of the a tensor3 is a function of a tuple (x,y).\n\nxx :: tensorComponent\nyx :: tensorComponent\nzx :: tensorComponent\nxy :: tensorComponent\nyy :: tensorComponent\nzy :: tensorComponent\nxz :: tensorComponent\nyz :: tensorComponent\nzz :: tensorComponent\n\n\n\n\n\n","category":"type"},{"location":"Common/#OpticalFibers.inverse","page":"Common functions","title":"OpticalFibers.inverse","text":"inverse(t::tensor3)\n\nReturns the inverse of the tensor t\n\n\n\n\n\n","category":"function"},{"location":"Common/#LinearAlgebra.det","page":"Common functions","title":"LinearAlgebra.det","text":"det(t::tensor3)\n\nReturns the determinant of the tensor t\n\n\n\n\n\n","category":"function"}]
}
